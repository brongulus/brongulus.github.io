<!DOCTYPE html>
<html lang="en-us">
<head>
    <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@1,6..96,500&family=Cormorant:ital,wght@0,400;1,300&family=Josefin+Sans:wght@200;300&family=Roboto+Mono:wght@300&family=Inter:wght@600&family=Source+Sans+Pro:wght@300;400&family=Source+Serif+Pro:ital,wght@0,300;0,400;1,300;1,400&family=Open+Sans&family=Playfair+Display&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/victormono@latest/dist/index.min.css">
    
    <script> 
        function setTheme() {
            if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.setAttribute("data-theme", "dark");
                return;
            }
            else {
                document.documentElement.setAttribute("data-theme", "light");
                return;
            }
      }
    </script>
    <script>
        if (localStorage.theme) document.documentElement.setAttribute("data-theme", localStorage.theme); 
    </script>
</head>
<body>
        <div class="content">
            <div class="custom-scrollbar">
                <div class = "container">
                <head>
  
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>IUSACO &middot; bacchanalian madness</title>
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="manifest" href=" /images/site.webmanifest">
  
  <link href="" rel="alternate" type="application/rss+xml" title="bacchanalian madness" />
</head>

                		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<div class="title" style="white-space: nowrap;">
						<h1 class="nav-title"><b>bacchanalian madness</b></h1>
					</div>
				</a>

				<aside>
    <ul>
        
        
            
                <li>
                    <a href="/about/about/">
                        
                        <span>About</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/blog/">
                        
                        <span>Blog</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/notes/">
                        
                        <span>Notes</span>
                    </a>
                </li>
            
        
        <li>
            <a href="/index.xml">RSS</a> 
        </li>
        <li>
            <div id="dark-mode-button">
                <input type="checkbox" class="toggle" id="check"/>
                <label for="check" class="themebox">
                </label>
            </div>
        </li>
    </ul>
</aside>


			</div>
		</nav>

                

<main>
	<div class="post">
		<div class="post-info">
    
    
    
    
        
        
        <time datetime="2022-06-05 00:00:00 &#43;0530 IST">June 5, 2022</time>
</div>

		<h1 class="post-title">IUSACO</h1>

		

		

		
			<nav id="TableOfContents">
  <ul>
    <li><a href="#input-and-output">Input and Output</a></li>
    <li><a href="#complexity-and-algorithm-analysis">Complexity and algorithm analysis</a></li>
    <li><a href="#built-in-data-structures">Built-in Data Structures</a></li>
    <li><a href="#elementary-techniques">Elementary Techniques</a></li>
    <li><a href="#graph-theory">Graph Theory</a></li>
    <li><a href="#more-techniques">More Techniques</a></li>
    <li><a href="#additional-topics">Additional Topics</a></li>
  </ul>
</nav>
		

		<h2 id="input-and-output">Input and Output</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">freopen</span><span class="p">(</span><span class="s">&#34;template.in&#34;</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">freopen</span><span class="p">(</span><span class="s">&#34;template.out&#34;</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>When using C++, arrays should be declared globally, or initialized to zeros if declared locally to avoid garbage values.</li>
<li>32bit int: \(\pm 2\times10^{9}\) v/s 64bit int: \(\pm 9\times 10^{18}\)</li>
</ul>
<h2 id="complexity-and-algorithm-analysis">Complexity and algorithm analysis</h2>
<ul>
<li>Elementary mathematical calculation: O(1)</li>
<li>Unordered set/map: O(1) per operation</li>
<li>Binary Search: O(log n)</li>
<li>Ordered set/map or Priority Queue: O(log n) per operation</li>
<li>Prime factorization or primality check for int: \(O(\sqrt{n})\)</li>
<li>Reading n inputs: O(n)</li>
<li>Iterating through n element array: O(n)</li>
<li>Sorting: Usually O(n log n) for <code>std::sort()</code></li>
<li>Iterating through all subsets of size k of input elements: O(\(n^{k}\) ), for triplets O(\(n^{3}\))</li>
<li>Iterating through all subsets: O(\(2^{n}\))</li>
<li>Iterating through all permutations: O(n!)</li>
</ul>
<h2 id="built-in-data-structures">Built-in Data Structures</h2>
<p>Data Structure determines how data is stored, each supports some operations efficiently. In following discussion, desired data type is put between <code>&lt;&gt;</code>. Most std structures support <code>size()</code> and <code>empty()</code> methods.</p>
<h3 id="iterators">Iterators</h3>
<p>Allows for traversal of a container with the help of a pointer.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span> <span class="c1">//prints the values in the vector using the pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span></code></pre></div><p>Alternate way to achieve the same with a for-each loop and <code>auto</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">element</span> <span class="p">:</span> <span class="n">v</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">;</span> <span class="c1">// prints values in vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span></code></pre></div><h3 id="dynamic-arrays">Dynamic Arrays</h3>
<p>Addition and deletion at the end in O(1) time and in the middle in O(n) time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// stores 1 to 10 in a dynamic array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span></code></pre></div><p>Vectors can be made static sized by initializing it with a size, <code>vector&lt;int&gt; v(30);</code>. They also support an <code>v.erase()</code> operation. A dynamic array can be sorted (default ascending) by <code>sort(v.begin(), v.end())</code>.</p>
<h3 id="stacks-and-queues">Stacks and Queues</h3>
<p><strong>Stacks</strong>: LIFO with operations <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) all of which are O(1). Declared as <code>stack&lt;int&gt; s</code>.</p>
<p><strong>Queues</strong>: FIFO with operations <code>push</code> (add in front), <code>pop</code> (remove at end) and <code>front</code> (show end) in O(1).</p>
<p><strong>Deques</strong>: Combination of a stack and a queue supporting insertion and deletion from both front and end. Operations are aptly named as <code>push_back</code>, <code>push_font</code>, <code>pop_back</code> and <code>pop_front</code>.</p>
<p><strong>Priority Queues</strong>: Supports insertion of elements and deletion and retrieval of element <em>with highest priority</em> in O(log n) where priority is based on a comparator function (highest element in front). Has <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) operations and is declared as <code>priority_queue&lt;int&gt; pq;</code>.</p>
<h3 id="sets">Sets</h3>
<p>A <em>set</em> is a collection of objects having no duplicates.</p>
<p><strong>Unordered Sets</strong>: Work by hashing that is, assigning a unique code to every object allowing for <code>insert</code>, <code>erase</code> and <code>count</code> (set contains element then 1 else 0) in O(1). Traversal is pointless. Declared as <code>unordered_set&lt;int&gt; s</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">element</span> <span class="p">:</span> <span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">element</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="c1">// iterating through a set, arbitrary order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span></code></pre></div><p><strong>Ordered Sets</strong>: Insertion, deletion and search needs O(log n) time. Has additional operations <code>begin()</code> (iterator to lowest element), <code>end()</code>, <code>lower_bound()</code> (iterator to least element â‰¥ some k) and <code>upper_bound()</code>.</p>
<p><strong>Multisets</strong>: A sorted set allowing multiple copies of same element, whose <code>count</code> operation returns the number of times an element is present in set. Time complexity of this operation is O(log n + f) where <em>log n</em> factor searches for element and <em>f</em> factor iterates through sorted set to get count. Declared as <code>multiset&lt;int&gt; ms</code>.</p>
<h3 id="maps">Maps</h3>
<p>A <em>map</em> is a set of <em>ordered pairs</em> called key and value where keys must be unique but values can be repeated. Supported operations are addition and removal of key-value pair and <em>retrieval</em> of values for a given key. Unordered maps perform aforementioned methods in O(1) whereas for ordered maps it&rsquo;s O(log n), sorted in order of key.</p>
<p><strong>Unordered Maps</strong>: In map <code>m</code>, <code>m[key] = value</code> operator assigns value to a key and places the pair on the map, <code>m[key]</code> returns value associated with the key, <code>count(key)</code> checks for existence of key in the map and <code>erase(it)</code> removes pair associated with a key or iterator. Declared as <code>unordered_map&lt;int, int&gt; m</code>.</p>
<p><strong>Ordered Maps</strong>: Supports additional operations <code>lower_bound</code> and <code>upper_bound</code> which return iterators pointing to lowest entry not less than/ strictly greater than a specified key.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// [(3,5); (11,4)]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">m</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">491</span><span class="p">;</span> <span class="c1">// [(3,5); (10,491); (11,4)]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 10 491
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 11 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span> <span class="c1">// [(3,5); (10,491)]
</span></span></span></code></pre></div><h2 id="elementary-techniques">Elementary Techniques</h2>
<h3 id="simulation">Simulation</h3>
<p>Simulation refers to the act of doing precisely what the problem statement states and nothing else; essentially simulating it.</p>
<h3 id="complete-search">Complete Search</h3>
<p>Brute forcing through all the possible cases in solution space to arrive at the solution. To iterate through all permutations of a list:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">check</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// process or check the current permutation for validity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</span></span></code></pre></div><h3 id="sorting-and-comparators">Sorting and Comparators</h3>
<p>C++ has built-in function for sorting in ascending order: <code>std::sort(arr, arr+N)</code> or for a vector <code>sort(v.begin(), v.end())</code>. For sorting in a self-defined order, one must use a custom comparator.</p>
<h3 id="greedy-algorithms">Greedy Algorithms</h3>
<p>Algorithms that select the most optimal choice at each step, instead of looking at the solution space as a whole. Usually in a greedy algorithm, there is a heuristic or value function that determines which choice is considered most optimal. The choice of the greedy algorithm matters too, for example in a scheduling problem choosing earliest starting next event would be incorrect, instead one should go for earliest ending next event because that would give one more choices for future events.</p>
<p>Greedy won&rsquo;t work in all scenarios though, for example in the fairly popular coin change problem, if the denominations are <code>{1,3,4}</code> then greedy solution would be <code>{4,1,1}</code> but the correct least amount of coins would be two <code>{3,3}</code>. Similarly it cannot work for the knapsack problem which is solved using Dynamic Programming.</p>
<h2 id="graph-theory">Graph Theory</h2>
<h3 id="representation">Representation</h3>
<p>Graphs (N vertices and M edges) are usually given in the format: <code>N</code> <code>M</code> followed by the <code>M edges</code> each showing the connecting vertices. One thing to note is that a graph should be stored globally and statically, for access outside the main method. A graph can be represented in three ways:</p>
<h4 id="adjacency-list">Adjacency List</h4>
<p>For using DFS, BFS, Dijkstra or other <code>single-source</code> traversal algorithms, it&rsquo;s the preferred way of storing graphs. In it, an array of length N of lists is maintained.
<a href="/ox-hugo/usaco-adj.png"><img src="/ox-hugo/usaco-adj.png" alt=""></a>
They take up <code>O(M+N)</code> space but allow for easy traversal among the neighbors of a vertex. Often, there&rsquo;s a need to maintain a <code>visited</code> array.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="n">b</span><span class="o">--</span><span class="p">;</span> <span class="c1">// subtract 1 for vertex since array is zero-indexed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">adj</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">adj</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// omit for directed graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// For a weighted graph:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Edge</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">to</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">weight</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="adjacency-matrix">Adjacency Matrix</h4>
<p>This is an <code>N x N</code> 2D array that stores for each pair of indices(a,b) whether an edge exists between them or not. Primarily used for Floyd-Warshall Algorithm.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="n">b</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">adj</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// or w for weighted graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">adj</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ignore this if directed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="edge-list">Edge List</h4>
<p>Usually used for weighted undirected graphs when sorting the edges by weight is needed (DSU). Its simply a single list of all edges <code>(a, b, w)</code> where a and b are the vertices and w is the weight of connecting edge. Each edge is added only oncce.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Edge</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">a</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">w</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">w</span><span class="p">;</span> <span class="c1">// ascending weight sort
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="n">b</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">));</span> <span class="c1">// add edge to list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="traversal">Traversal</h3>
<h4 id="breadth-first-search--bfs">Breadth-First Search (BFS)</h4>
<p>Visits nodes in order of distance away from the starting node; first visit nodes that are one edge away then those that are two edges away and so on. It can be used for finding the distance from a starting node to all nodes in an unweighted graph.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">total_nodes</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">memset</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dist</span><span class="p">);</span> <span class="c1">// fill distance array with -1s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">e</span><span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">seen</span> <span class="o">==</span> <span class="n">total_nodes</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// see: https://observablehq.com/@yurivish/efficient-graph-search
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Once BFS finishes, the array <code>dist</code> contains the distances from the start node to each node.</p>
<h4 id="depth-first-search--dfs">Depth-First Search (DFS)</h4>
<p>Continues down a single path as far as possible until it has no more vertices to visit along that path, then backtracks and finds more vertices to visit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">next</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">      <span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If stack overflows are encountered with recursive DFS, it can be implemented iteravely by storing nodes in the BFS implementation on a stack instead of a queue.</p>
<h3 id="floodfill">Floodfill</h3>
<p>Its DFS but on a grid and the aim is to find the connected component of all the connected cells with the same number. As opposed to an explicit graph where the edges are given, a grid is an implicit graph where the neighbours are nodes adjacent in the four directions.</p>
<p>When doing floodfill, an <code>N x M</code> array of bools <code>visited</code> is maintained and a global variable for the size of currently visiting component. The search function is called recursively from squares on all four sides of the current one.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">grid</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">currentCompSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">floodfill</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// outside grid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">color</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// wrong color
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// already visited
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// mark current sq as visited
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">currentCompSize</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// recursively call floodfill for neighbour sqs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">floodfill</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">floodfill</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">floodfill</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">floodfill</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">   * additional stuff here
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">        <span class="n">currentCompSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">floodfill</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="disjoint-set-union-data-structure">Disjoint-Set Union Data Structure</h3>
<p>It supports two operations:</p>
<ul>
<li>Add an edge between two nodes</li>
<li>Check if two nodes are connected</li>
</ul>
<p>For this, the sets are stored as trees; initially each node is its own set then the sets are combined when an edge is added between two nodes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span> <span class="c1">// store root of each set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">initialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// initially, root of each set is node itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="c1">// find root of set of x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// if x is its parent, it is the root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="c1">// merge sets of a and b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// find a&#39;s root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>        <span class="c1">// find b&#39;s root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parent</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>        <span class="c1">// merge sets by setting parent of d to c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The naive recursive implementation of find can be improved from <code>O(nm)</code> by path compression; the idea being reassignment of nodes on recursive calls to <code>find</code> to prevent formation of long chains and the runtime becomes <code>O(n log n)</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="miscellaneous">Miscellaneous</h3>
<ul>
<li>DAGs (Directed Acyclic graphs) by virtue of not having any cycles allows them to have an ordering of nodes such that for any edge from <em>u</em> to <em>v</em>, <em>u</em> appears before <em>v</em> (topological sorting).</li>
<li>Bipartite graph is such that each node can only be colored by 2 colors such that no adjacent nodes share the same colour. A graph is bipartite iff there are no cycles of odd length. A modified BFS can be use to check whether a graph is bipartite or not.</li>
</ul>
<h2 id="more-techniques">More Techniques</h2>
<h3 id="prefix-sums">Prefix Sums</h3>
<p>To process queries to find the sum of elements between two indices in a list, prefix sum is useful. Using 1-index in the array is beneficial i.e. assigning <code>arr[0] = 0</code> and hence <code>prefix[0] = 0</code>.</p>
<p>\(prefix[k] = \sum_{i=1}^{k}arr[i] = prefix[k-1] + arr[k]\)</p>
<p>For processing Q queries consisting on an array of N elements, the complexity is <code>O(N+Q)</code>.</p>
<div class="note">
<p>TODO: DP, 2D prefix sum as 1-D only</p>
</div>
<h3 id="binary-search">Binary Search</h3>
<h3 id="basic-number-theory">Basic Number Theory</h3>
<p>Prime factorization of a number is computed by this algorithm in \(O(\sqrt{n})\):
<a href="/ox-hugo/usaco-pf.png"><img src="/ox-hugo/usaco-pf.png" alt=""></a></p>
<table>
<thead>
<tr>
<th>i</th>
<th>n</th>
<th>v</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>252</td>
<td>{}</td>
</tr>
<tr>
<td>2</td>
<td>126</td>
<td>{2}</td>
</tr>
<tr>
<td>2</td>
<td>63</td>
<td>{2,2}</td>
</tr>
<tr>
<td>3</td>
<td>21</td>
<td>{2,2,3}</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>{2,2,3,3}</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>{2,2,3,3,7}</td>
</tr>
</tbody>
</table>
<p>GCD using Euclidean Algorithm in <code>O(log min(a,b))</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>LCM can be computed using GCD by \(\frac{a \times b}{gcd(a,b)}\)</p>
<p>Modular Arithmetic is useful for dealing with overflows by taking remainders:</p>
<p>\[\begin{align*}
(a \pm b)\mod m &amp;= (a\mod m \pm b\mod m)\mod m \\
(a \times b)\mod m &amp;= ((a\mod m) \times (b\mod m))\mod m \\
a^{b}\mod m &amp;= (a\mod m)^{b}\mod m
\end{align*}\]</p>
<h2 id="additional-topics">Additional Topics</h2>
<ul>
<li>Two Pointers <br />
Iterate across an array that track the start and end of an interval or values in a sorted array. Both pointers are monotonic i.e. start at one end of array and move in only one direction.</li>
</ul>
<h3 id="line-sweep">Line Sweep</h3>
<h3 id="bitwise-operations">Bitwise Operations</h3>
<h3 id="ad-hoc">Ad-hoc</h3>

    
    

		
	</div>

	<div class="pagination">
		<a href="/blog/nix-intro/" class="left arrow">&#8592;</a>
		<a href="/notes/elements-of-computing-systems/" class="right arrow">&#8594;</a>
		<a href="/" class="bottom">Home</a>
	</div>
	
  
					
  

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
	<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
	</script>
</main>


                		<footer>
			
			<span>
			&copy; <time datetime="2024-08-12 21:04:51.61383 &#43;0530 IST m=&#43;0.096408007">2024</time> . Made with <a href='https://gohugo.io'>Hugo</a> and <a href='https://orgmode.org'>Org</a> using the <a href='https://github.com/brongulus/tufte-hugo'>Tufte</a> theme.
			</span>
		</footer>

                </div>
            </div>
        </div>
    <script> 
        const toggleSwitch = document.querySelector('#dark-mode-button input[type="checkbox"]');
        if (localStorage.theme) {
            toggleSwitch.checked = localStorage.theme === "dark";
        }
        function switchTheme(e) {
        const theme = e.target.checked ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.theme = theme;
        }
        toggleSwitch.addEventListener("change", switchTheme);
    </script>
    </body>
</html>
