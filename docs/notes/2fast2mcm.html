<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2026 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2 Fast 2 MCM</title>
<meta name="author" content="Tak" />
<meta name="generator" content="Org Mode" />
<script src='/css/head.js'></script> <link rel='stylesheet' type='text/css' href='/css/stylesheet.css'>
<script type="module"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs'; import elkLayouts from 'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk/dist/mermaid-layout-elk.esm.min.mjs'; mermaid.registerLayoutLoaders(elkLayouts); const currentTheme = (localStorage.getItem('theme') === 'dark') ? 'dark' : 'default'; var config = {startOnLoad: true, theme: currentTheme, align: 'center'}; mermaid.initialize(config); const toggleButton = document.querySelector('#dark-mode-button'); if (toggleButton) {toggleButton.addEventListener('click', () => {window.location.reload();});} </script>
</head>
<body>
<div id="nav" class="status">
<a href='/'>bacchanalian madness</a><a href='/rss.xml'>
    <button id='rss-button' aria-label='Get RSS feed' type='button'>
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 448 512' fill='currentColor'>
        <path d='M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z'></path>
      </svg>
    </button>
  </a><button id='dark-mode-button' aria-label='Toggle Dark Mode' type='button'>
    <svg id='moon-icon' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'>
      <path d='M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z'></path>
    </svg>
    <svg id='sun-icon' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor' style='display: none;'>
      <path d='M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z' fill-rule='evenodd' clip-rule='evenodd'></path>
    </svg>
  </button>
</div>
<div id="content" class="content">
<header>
<h1 class="title">2 Fast 2 MCM</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org783526e">Machine Controller Manager Architecture</a></li>
<li><a href="#org9c90ee5">Machine Controller Core Flows</a></li>
<li><a href="#org74c734e">Safety Controller</a></li>
<li><a href="#org0805af7">MachineSet Controller</a></li>
<li><a href="#org2256e23">MachineDeployment Controller</a></li>
<li><a href="#org59125ff">Summary</a></li>
</ul>
</div>
</nav>
<p>These visual representations helps understand the complex workflows within the Machine Controller Manager.
</p>
<div id="outline-container-org783526e" class="outline-2">
<h2 id="org783526e">Machine Controller Manager Architecture</h2>
<div class="outline-text-2" id="text-org783526e">
<ul class="org-ul">
<li>The system consists of three main controllers working in concert</li>
<li>Each controller handles specific aspects of machine lifecycle management</li>
<li>Interfaces with both cloud providers and Kubernetes clusters</li>
<li>Manages the full lifecycle of machines from creation to deletion</li>
</ul>

<p>Let's start with an overview of the main components and their interactions:
</p>

<pre class="mermaid">
stateDiagram-v2
    direction TB

    state "Machine Controller Manager" as MCM {
        state "Machine Controller" as MC
        state "Safety Controller" as SC
        state "MCM Controller" as MCMC

        [*] --> MC
        [*] --> SC
        [*] --> MCMC
    }

    state "Cloud Provider" as CP {
        VMs
        API
    }

    state "Kubernetes Cluster" as K8S {
        state "Control Plane" as CP_K8S {
            API_Server
            etcd
        }

        state "Node Components" as NC {
            kubelet
            container_runtime
        }
    }

    MCM --> CP : Manages VMs
    MCM --> K8S : Manages Nodes

    note right of MCM
        Handles:
        - Machine lifecycle
        - Safety checks
        - Deployments/Sets
    end note
</pre>
</div>
</div>
<div id="outline-container-org9c90ee5" class="outline-2">
<h2 id="org9c90ee5">Machine Controller Core Flows</h2>
<div class="outline-text-2" id="text-org9c90ee5">
<p>Now, let's dive into the Machine Controller's core reconciliation flows for different resources. It handles three main types of reconciliation:
</p>
<ul class="org-ul">
<li>Secret Reconciliation: Manages secrets referenced by MachineClasses</li>
<li>MachineClass Reconciliation: Handles machine class lifecycle</li>
<li>Machine Reconciliation: Core machine lifecycle management</li>
</ul>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "Machine Controller" as MC {
        state "Secret Reconciliation" as SR {
            [*] --> FetchSecret
            FetchSecret --> GetMachineClass
            GetMachineClass --> CheckReferences
            CheckReferences --> FinalizerAdd : Has References
            CheckReferences --> FinalizerRemove : No References
            FinalizerAdd --> [*]
            FinalizerRemove --> [*]
        }

        state "MachineClass Reconciliation" as MCR {
            [*] --> FetchClass
            FetchClass --> GetMachines
            GetMachines --> CheckMachines
            CheckMachines --> AddFinalizer : Has Machines
            CheckMachines --> RemoveFinalizer : No Machines
            AddFinalizer --> EnqueueMachines
            EnqueueMachines --> [*]
            RemoveFinalizer --> [*]
        }

        state "Machine Reconciliation" as MR {
            [*] --> FetchMachine
            FetchMachine --> CheckFrozen

            CheckFrozen --> ValidateMachine : Not Frozen
            CheckFrozen --> RetryLater : Frozen

            ValidateMachine --> ValidateMachineClass
            VaildateMachineClass --> DeletionTimestamp

            DeletionTimestamp --> DeletionFlow : Deletion Requested
            DeletionTimestamp --> AddFinalizers : No Deletion

            AddFinalizers --> CheckPhase&NodeLabel

            CheckPhase&NodeLabel --> ReconcileHealth : Has Node & Non-empty phase
            CheckPhase&NodeLabel --> CreationFlow : No Node or<br/>CrashLoopBackOff<br/>or EmptyPhase

            ReconcileHealth --> SyncNodeName
            SyncNodeName --> SyncTemplates
            SyncTemplates --> [*]

            CreationFlow --> [*]
            DeletionFlow --> [*]
        }
    }
</pre>
</div>
<div id="outline-container-org9a47b6b" class="outline-3">
<h3 id="org9a47b6b">Machine Creation</h3>
<div class="outline-text-3" id="text-org9a47b6b">
<p>Machine Creation Flow:
</p>
<ul class="org-ul">
<li>Complex process involving multiple status checks</li>
<li>Handles initialization and error cases</li>
<li>Includes node verification and cleanup of stale resources</li>
<li>Multiple retry mechanisms for resilience</li>
</ul>

<pre class="mermaid">
---
  config:
    look: handDrawn
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state "From <u>CreateResponse</u>: Assign Node Name & ProviderID" as ANPIDCMR
        state "From <u>GetMachineStatusResponse</u>: Assign Node Name & ProviderID" as ANPIDGMS
        state "From <u>GetMachineStatusResponse</u>: Assign Node Name & ProviderID" as ANPIDGMSR
        state "Assign Node Name<br/>from Machine label" as ANML
        state "Phase: <i>Pending</i><br/>State: <i>Processing</i><br/>OpType: Create" as CPPP
        state "State: <i>Failed</i><br/>OpType: <i>Create</i>" as SFFF

        [*] --> AddBootToken&MachineName
        AddBootToken&MachineName --> GetMachineStatus:::imp

        GetMachineStatus:::imp --> ANPIDGMS : Success
        ANPIDGMS --> UpdateAnnotationsLabels
        UpdateAnnotationsLabels --> CPPP : Phase <i>""(empty) or CrashLoopBackOff</i>
        CPPP --> StatusUpdate
        StatusUpdate --> [*]

        GetMachineStatus:::imp --> CheckNodeExists : NotFound or Unimplemented
        CheckNodeExists --> ANML : Node Exists
        ANML --> UpdateAnnotationsLabels

        CheckNodeExists --> CreateMachine:::imp : No Node
        CreateMachine:::imp --> ANPIDCMR : Successful creation
        CreateMachine:::imp --> CheckFailurePhase : Creation Error
        ANPIDCMR --> SetUninitialized : Node name is Machine Name
        SetUninitialized --> UpdateAnnotationLabel
        UpdateAnnotationLabel --> InitializeMachine:::imp
        InitializeMachine:::imp --> [*]

        ANPIDCMR --> DeleteMachine:::imp : <u>Stale Node</u><br/>NodeName is not MachineName
        DeleteMachine:::imp --> SFFF: "VM using old node obj"

        GetMachineStatus:::imp --> ANPIDGMSR : Uninitialized
        ANPIDGMSR --> SetUninitialized

        GetMachineStatus:::imp --> CheckFailurePhase : Other Errors
        CheckFailurePhase --> Failed : Timeout
        CheckFailurePhase --> CrashLoopBackOff : Not timed out
        Failed --> SFFF
        CrashLoopBackOff --> SFFF

        SFFF --> [*]

</pre>
</div>
</div>
<div id="outline-container-orge99815c" class="outline-3">
<h3 id="orge99815c">Health Check</h3>
<div class="outline-text-3" id="text-orge99815c">
<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "Health Reconciliation" as HR {
        state "Phase: <i>Unknown</i><br/>State: <i>Processing</i><br/>LastOp: <i>HealthChk</i>" as PUSP
        state "Phase: <i>Failed</i><br/>State: <i>Failed</i>" as PFSF
        state "LastOp State: Successful<br/>Phase: Running" as SSPR

        [*] --> GetMachineNode
        GetMachineNode --> PUSP : Not Found & RunningPhase<br/>Node object missing
        GetMachineNode --> Found

        Found --> MachineCondSetToNodeCond : NodeCondition != MachineCondition
        Found --> isHealthy : TODO (isHealthy)

        GetMachineNode --> CreationTimeout : PendingPhase
        GetMachineNode --> HealthTimeout : UnknownPhase

        CreationTimeout --> PFSF : Now - LastUpdateTime > Timeout
        HealthTimeout --> GetDeploymentName : Now - LastUpdateTime > Timeout
        CreationTimeout --> EnqueueAfter : Not timed out
        HealthTimeout --> EnqueueAfter : Not timed out


        GetDeploymentName --> RegisterPermit
        RegisterPermit --> TryMarkingMachineFailed
        TryMarkingMachineFailed --> InProgressMachines++ : Phase not<br/>Unknown or Running<br/>Machines "getting replaced"
        InProgressMachines++ --> PFSF:  InProgressMachines < MaxReplacements(1)

        MachineCondSetToNodeCond --> isHealthy
        isHealthy --> PUSP: Not Healthy & RunningPhase
        isHealthy --> CheckLastOp : Healthy & NotRunningPhase &<br/>NoCriticalComponentNotReadyTaint

        CheckLastOp --> DeleteBootstrapToken: TypeCreate &<br/> State is not Successful<br/>(Machine creation happened)
        CheckLastOp --> LastOpType=HealthChk: Not Create<br/>(Machine re-joined)

        DeleteBootstrapToken --> SSPR
        LastOpType=HealthChk --> SSPR

        SSPR --> UpdateStatus
        PUSP --> UpdateStatus
        PFSF --> UpdateStatus

        UpdateStatus --> [*]
        EnqueueAfter --> [*]
    }       

</pre>
</div>
</div>
<div id="outline-container-orge9e9fd3" class="outline-3">
<h3 id="orge9e9fd3">Machine Deletion</h3>
<div class="outline-text-3" id="text-orge9e9fd3">
<p>Machine Deletion Flow:
</p>
<ul class="org-ul">
<li>Carefully orchestrated process to ensure clean resource cleanup</li>
<li>Involves multiple phases from drain to final cleanup</li>
<li>Handles volume attachments and node cleanup</li>
<li>Includes finalizer management for resource protection</li>
</ul>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "Deletion Flow" as DF {
        direction LR
        state "ProcessPhase" as PP
        state "UpdateStatus" as US

        [*] --> CheckFinalizers
        CheckFinalizers --> SetTerminating
        SetTerminating --> PP

        PP --> GetVMStatus
        GetVMStatus --> [*]
        PP --> InitiateDrain
        InitiateDrain --> [*]
        PP --> DeleteVolumeAttachments
        DeleteVolumeAttachments --> [*]
        PP --> InitiateVMDeletion
        InitiateVMDeletion --> [*]
        PP --> InitiateNodeDeletion
        InitiateNodeDeletion --> [*]
        PP --> RemoveFinalizers
        RemoveFinalizers --> [*]
        PP --> US
        US --> [*]
    }
</pre>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "Initiate Drain" as ND {
        [*] --> ValidateNode
        state "UpdateStatus" as USD
        state "State: Processing<br/>Type: Delete" as SPTD
        state "CheckNodeCondition<br/>'Ready' or 'Read-only FS'" as CNC
        state "Phase is not Terminating" as NAT
        state "Terminating<br/>Reason: Unhealthy" as TRU
        state "Terminating<br/>Reason: ScaleDown" as TRSD
        state "SkipDrain<br/>State: Failed" as CUFail
        state "State: Processing<br/>Desc: DelVolAttachments" as SPDDVA
        state "State: Processing<br/>Desc: InitVMDeletion" as SPDIVD
        state "State: Failed<br/>Desc: InitiateDrain" as SFDID

        ValidateNode --> SPTD : NodeName is empty
        SPTD --> USD
        ValidateNode --> CNC
        CNC --> ForceDeletion : Read-Only/NotReady &<br/>Last-transition Timeout
        CNC --> NormalDrain : Healthy
        CNC --> ForceDeletion : "force-delete" label on machine or Drain<br/> Timeout on deletion

        ForceDeletion --> UpdateTerminationCondition
        NormalDrain --> UpdateTerminationCondition

        UpdateTerminationCondition --> RunDrain : Phase is empty or CrashLoopBackOff
        UpdateTerminationCondition --> NAT : Non-creation Phase
        NAT --> TRU : Phase is failed
        NAT --> TRSD : Phase not failed
        TRU --> TerminationConditionUpdate
        TRSD --> TerminationConditionUpdate

        TerminationConditionUpdate --> CUFail : Update failure<br/>during NormalDrain
        TerminationConditionUpdate --> RunDrain : Update failure<br/>during ForceDeletion
        TerminationConditionUpdate --> RunDrain : Update Successful
        CUFail --> USD

        RunDrain --> SPDDVA : Drain successful<br/>during ForceDeletion
        RunDrain --> SPDIVD : Drain successful<br/>during NormalDrain
        RunDrain --> SPDDVA : Drain failed<br/>"force-delete" label present
        RunDrain --> SFDID : Drain failed<br/>"force-delete" label absent

        SPDDVA --> USD
        SPDIVD --> USD
        SFDID --> USD

        USD --> [*]
    }
</pre>

<p>Let's visualize the Node Drain process, which is a critical part of machine deletion:
</p>
<ul class="org-ul">
<li>Sophisticated pod eviction handling</li>
<li>Supports both forced and normal drain scenarios</li>
<li>Handles PDB (Pod Disruption Budget) violations</li>
<li>Includes parallel and serial eviction strategies</li>
</ul>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "RunDrain" as Normal {
        state "CordonNode (Sealing off)<br/>(Set Unschedulable to true)" as CN
        [*] --> CN
        CN --> WaitForPodCacheSync
        WaitForPodCacheSync --> GetPodsForDeletion : TODO

        %% http://localhost:3000/machine-controller/node_drain.html#drainoptionsgetpodsfordeletion
        %% mirrorPodFilter: pod doesnt have MirrorPodAnnotation (set by kubelet when creating mirror pods)
        %% localStorageFilter
        %% unreplicatedFilter
        %% daemonSetFilter

        GetPodsForDeletion --> DeleteOrEvictPods

        DeleteOrEvictPods --> UpdateNodeCondition
        UpdateNodeCondition --> [*]

        state "DeleteOrEvictPods" as EP {
            [*] --> CheckEvictionSupport

            CheckEvictionSupport --> ParallelEviction : ForceDeletion
            CheckEvictionSupport --> MixedEviction : NormalDrain

            MixedEviction --> ParallelEvictNoPV
            MixedEviction --> SerialEvictWithPV

            ParallelEvictNoPV --> WaitForEviction
            SerialEvictWithPV --> WaitForEviction
            ParallelEviction --> WaitForEviction
            WaitForEviction --> HandlePDBViolation
            HandlePDBViolation --> RetryEviction
            RetryEviction --> [*]
        }
}
</pre>

<pre class="mermaid">
---
title: EvictPodsNoPV
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state "Retry count >= MaxEvictRetries" as Term
        state "Set attemptEvict as False" as AEF
        state "Sleep(EvictRetryInterval)" as SRC

        [*] --> Term:::imp

        Term:::imp --> CheckAttemptEvict : No
        Term:::imp --> AEF : Yes
        AEF --> CheckAttemptEvict

        CheckAttemptEvict --> EvictPod : True
        CheckAttemptEvict --> DeletePod : False

        EvictPod --> CheckErr
        DeletePod --> CheckErr

        CheckErr --> BreakLoop:::imp : nil
        CheckErr --> LogEvict : notFound
        CheckErr --> EvictFailErr : AttemptEvict is False
        CheckErr --> PDBViolation : APIErr too many req

        PDBViolation --> GetPDB

        GetPDB --> SRC : No PDB
        GetPDB --> CheckMisconfigured : PDB exists

        CheckMisconfigured --> MisconfigErr : Generation is ObserverGen<br/>HealthyPods >= ExpectedPods<br/>DisruptionsAllowed is 0
        CheckMisconfigured --> SRC : No

        SRC:::imp --> Term : count++


        BreakLoop:::imp --> ReturnSuccess:::imp : ForceDeletion
        BreakLoop:::imp --> GetTerminationGracePeriod : NormalDrain

        GetTerminationGracePeriod --> SetToTimeout : GracePeriod > Timeout
        GetTerminationGracePeriod --> WaitForDeletion : Grace < Timeout
        SetToTimeout --> WaitForDeletion

        WaitForDeletion --> TimeoutErr : timeout &<br/>pod exists
        WaitForDeletion --> WaitErr : err
        WaitForDeletion --> ReturnSuccess:::imp : timeout &<br/>pod deleted

        LogEvict --> [*]
        EvictFailErr --> [*]
        MisconfigErr --> [*]
        TimeoutErr --> [*]
        WaitErr --> [*]
        ReturnSuccess:::imp --> [*]
</pre>

<pre class="mermaid">
---
title: EvictPodsWithPV
config:
  layout: elk
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state "Retry count < MaxEvictRetries" as Term
        state "Sleep(EvictRetryInterval)" as SRC
        state "CheckRemainingPods" as CRP

        [*] --> SortPodsByPriority
        SortPodsByPriority --> podVolumeInfoMap
        note left of podVolumeInfoMap
            Creates a map from pod to list of attached PVs (VolName, VolID -> GetVolumeID)
        end note

        podVolumeInfoMap --> AttemptEvict
        AttemptEvict --> evictPodPVInternal(Delete):::imp : false
        AttemptEvict --> Term:::imp : true
        Term:::imp --> evictPodPVInternal(Evict):::imp : true
        evictPodPVInternal(Evict):::imp --> break:::imp : FastTrack or<br/>All pods evicted
        evictPodPVInternal(Evict):::imp --> SRC : Not FastTrack and<br/>Pods Remaining
        SRC --> Term:::imp : count++

        Term:::imp --> evictPodPVInternal(Delete):::imp : false<br/>Not FastTrack and<br/>Pods Remaining
        break:::imp --> [*] : All pods evicted

        break:::imp --> CRP : FastTrack
        evictPodPVInternal(Delete):::imp --> CRP

        CRP --> Success:::imp : Node Not Found
        CRP --> ChkAttemptEvict
        ChkAttemptEvict --> EvictErr : True
        ChkAttemptEvict --> DeleteErr : False

</pre>

<pre class="mermaid">
---
title: EvictPodsWithPVInternal
config:
  layout: elk
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state "Add Pod to RetryPods" as Retry
        state "Log NotFound<br/>DeleteWorker" as LogNotFound
        [*] --> SelectPod : Start Eviction Process

        SelectPod --> CheckContextTimeout:::imp

        CheckContextTimeout:::imp --> AbortProcess : Context Done
        CheckContextTimeout:::imp --> AddWorker(AttachmentHandler) : Context Not Done

        AddWorker(AttachmentHandler) --> EvictOrDelete

        EvictOrDelete --> CheckEvictionResult:::imp

        CheckEvictionResult:::imp --> EvictionFailed
        EvictionFailed --> PDBViolation : Eviction Attempted &<br/>TooManyRequests
        EvictionFailed --> PodAlreadyGone : Pod Not Found
        EvictionFailed --> EvictionError : Other Errors
        CheckEvictionResult:::imp --> WaitForVolumeDetach : Successful Eviction

        PDBViolation --> GetPDB
        GetPDB --> CheckMisconfigured : PDB Exists
        GetPDB --> Retry : NoPDB
        CheckMisconfigured --> MisconfigErr : Generation is ObserverGen<br/>HealthyPods >= ExpectedPods<br/>DisruptionsAllowed is 0
        CheckMisconfigured --> Retry:::imp : NotMisconfig
        MisconfigErr --> DeleteWorker

        PodAlreadyGone --> DeleteWorker

        EvictionError --> Retry:::imp

        WaitForVolumeDetach --> CheckDetachResult:::imp : TerminationGracePeriod + DetachTimeout

        CheckDetachResult:::imp --> LogNotFound : Node Not Found
        CheckDetachResult:::imp --> DetachError : Detach Failed
        CheckDetachResult:::imp --> WaitForReattach : Successful Detach

        LogNotFound --> AbortProcess
        DetachError --> DeleteWorker

        WaitForReattach --> CheckReattachResult:::imp : PvReattachTimeout

        CheckReattachResult:::imp --> ReattachTimeout : Timeout
        CheckReattachResult:::imp --> LogError : Reattach Failed
        CheckReattachResult:::imp --> SuccessfulEviction:::imp : Successful Reattach

        ReattachTimeout --> DeleteWorker : TODO IsThisCorrect?
        LogError --> DeleteWorker
        SuccessfulEviction:::imp --> DeleteWorker : Pod Processed

        DeleteWorker --> [*]
        Retry:::imp --> DeleteWorker
        AbortProcess --> Exit:::imp : Terminate (FastTrack)<br/>Return Remaining Pods
</pre>
</div>
</div>
</div>
<div id="outline-container-org74c734e" class="outline-2">
<h2 id="org74c734e">Safety Controller</h2>
<div class="outline-text-2" id="text-org74c734e">
<ol class="org-ol">
<li>Orphan VM Check:
<ul class="org-ul">
<li>Runs periodically (every 15 minutes) to detect and clean up orphaned VMs</li>
<li>Lists all VMs in the cloud provider matching the cluster's tag</li>
<li>Maps VMs to machine objects using ProviderID</li>
<li>Handles nodes without machine objects:
<ul class="org-ul">
<li>Adds `NotManagedByMCM` annotation after timeout</li>
<li>Removes annotation if machine object is found</li>
</ul></li>
<li>Logs all cleanup operations for audit purposes</li>
</ul></li>

<li>API Server Safety:
<ul class="org-ul">
<li>Monitors connectivity to both control and target API servers</li>
<li>Implements a freezing mechanism when API servers are unreachable</li>
<li>Manages machine controller state based on API server health:
<ul class="org-ul">
<li>Freezes operations if timeout exceeded</li>
<li>Unfreezes when API servers become available</li>
</ul></li>
<li>Handles machine status updates during API server recovery</li>
</ul></li>
</ol>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "Safety Controller" as SC {
        state "Orphan VM Check" as OVC {
            [*] --> ListCloudVMs
            ListCloudVMs --> MapToMachines
            MapToMachines --> CheckOrphans

            state "CheckOrphans" as CO {
                [*] --> NoMachineObject
                NoMachineObject --> ConfirmDeletion
                ConfirmDeletion --> DeleteVM
                DeleteVM --> LogDeletion
            }

            CheckOrphans --> AnnotateNodes

            state "AnnotateNodes" as AN {
                [*] --> CheckNodeMachine
                CheckNodeMachine --> MultipleMatch : Multiple Machines
                CheckNodeMachine --> NoMatch : No Machine
                CheckNodeMachine --> SingleMatch : One Machine

                NoMatch --> TimeoutCheck
                TimeoutCheck --> AddAnnotation : Timeout Exceeded

                SingleMatch --> RemoveAnnotation : Has Annotation

                AddAnnotation --> UpdateNode
                RemoveAnnotation --> UpdateNode
            }
        }

        state "API Server Safety" as ASS {
            [*] --> CheckFrozen
            CheckFrozen --> CheckAPIServer : Frozen
            CheckFrozen --> MonitorAPI : Not Frozen

            CheckAPIServer --> Unfreeze : API Up
            CheckAPIServer --> Requeue : API Down

            MonitorAPI --> SetInactiveTime : API Down
            MonitorAPI --> ClearInactiveTime : API Up

            SetInactiveTime --> CheckTimeout
            CheckTimeout --> Freeze : Timeout Exceeded

            Unfreeze --> UpdateMachines
            UpdateMachines --> ResetTimeout
        }
    }
</pre>
</div>
</div>
<div id="outline-container-org0805af7" class="outline-2">
<h2 id="org0805af7">MachineSet Controller</h2>
<div class="outline-text-2" id="text-org0805af7">
<ol class="org-ol">
<li>Core Reconciliation:
<ul class="org-ul">
<li>Validates MachineSet specifications</li>
<li>Manages finalizers for proper cleanup</li>
<li>Implements machine ownership through controller references</li>
<li>Synchronizes node templates and configurations</li>
</ul></li>

<li>Replica Management:
<ul class="org-ul">
<li>Implements sophisticated scaling logic:
<ul class="org-ul">
<li>Slow-start batching for scale-up operations</li>
<li>Prioritized scale-down based on machine health</li>
</ul></li>
<li>Handles stale machine cleanup</li>
<li>Maintains desired replica count</li>
<li>Updates status to reflect current state</li>
</ul></li>
</ol>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "MachineSet Controller" as MSC {
        state "Sync MachineSet<br/>NodeTemplate<br/>to Machine" as SyncNodeTemplates
        state "Sync MachineSet<br/>MachineConfiguration<br/>to Machine" as SyncMachineConfig
        state "Sync MachineSet<br/>MachineClass.Kind<br/>to Machine" as SyncMachineKind

        [*] --> FetchMachineSet
        FetchMachineSet --> ValidateSpec
        ValidateSpec --> AddFinalizers : Deletion Not Requested

        AddFinalizers --> ClaimMachines

        state "ClaimMachines (Returns filtered machines)" as CM {
            [*] --> CreateControllerRefMgr
            CreateControllerRefMgr --> GetControllerRef
            GetControllerRef --> Orphan : Nil<br/>(No Owner)
            GetControllerRef --> CheckUID : Not Nil<br/>(Owner Exists)

            CheckUID --> Ignore : Mismatch<br/>(Wrong Owner)
            CheckUID --> MatchSelector : UID Same
            Orphan --> CheckDeletion
            CheckDeletion --> SelectorMatch : No Deletion
            SelectorMatch --> AdoptOrphan : Selector Match

            MatchSelector --> KeepClaim : Selector Match<br/>Already Owned
            MatchSelector --> DeletionCheck : Selector Mismatch
            DeletionCheck --> AttemptRelease : No Deletion

            KeepClaim --> AddToClaimed
            AdoptOrphan --> AddToClaimed
            AttemptRelease --> RemoveFromClaimed
        }

        ClaimMachines --> SyncNodeTemplates
        SyncNodeTemplates --> SyncMachineConfig
        SyncMachineConfig --> SyncMachineKind
        SyncMachineKind --> CheckFilteredMachines : Deletion Requested
        SyncMachineKind --> ManageReplicas : No Deletion

        CheckFilteredMachines --> RemoveFinalizers : Zero Owned Machines
        CheckFilteredMachines --> CheckFinalizerPresent : Backed Machines
        CheckFinalizerPresent --> TerminateMachines
        RemoveFinalizers --> UpdateStatus
        TerminateMachines --> UpdateStatus

        state "ManageReplicas" as MR {
            [*] --> CheckMachinePhase
            CheckMachinePhase --> ActiveMachines : Phase<br/>NotFailedOrTerminating
            CheckMachinePhase --> StaleMachines : PhaseFailed

            ActiveMachines --> CheckDiff
            StaleMachines --> TerminateStale
            TerminateStale --> CheckDiff

            CheckDiff --> ScaleUp : ActiveMachines<br/>Less than<br/>Replica Count
            CheckDiff --> ScaleDown : ActiveMachines<br/>More than<br/>Replica Count

            ScaleUp --> NotFrozenAnd<br/>NotToBeDeleted
            NotFrozenAnd<br/>NotToBeDeleted --> SlowStartBatch : TODO Expectations
            SlowStartBatch --> CreateMachines

            ScaleDown --> SortMachines
            SortMachines --> DeleteExcess
        }

        ManageReplicas --> UpdateStatus
        UpdateStatus --> [*]
    }
</pre>
</div>
</div>
<div id="outline-container-org2256e23" class="outline-2">
<h2 id="org2256e23">MachineDeployment Controller</h2>
<div class="outline-text-2" id="text-org2256e23">
<p>Deployment Management:
</p>
<ul class="org-ul">
<li>Handles multiple MachineSets for a deployment</li>
<li>Maintains deployment history through revisions</li>
<li>Supports pausing and resuming deployments</li>
<li>Implements rollback functionality</li>

<li>Deployment Strategies:
<ul class="org-ul">
<li>Recreate Strategy:
<ul class="org-ul">
<li>Scales down old MachineSets completely</li>
<li>Creates and scales up new MachineSet</li>
<li>Ensures clean cutover between versions</li>
</ul></li>

<li>Rolling Update Strategy:
<ul class="org-ul">
<li>Gradually scales up new MachineSet</li>
<li>Gradually scales down old MachineSets</li>
<li>Maintains availability during updates</li>
<li>Handles surge and unavailability constraints</li>
</ul></li>
</ul></li>

<li>Scaling Operations:
<ul class="org-ul">
<li>Detects and handles scaling events</li>
<li>Manages desired replica counts across MachineSets</li>
<li>Updates annotations for autoscaler integration</li>
<li>Ensures proper resource cleanup</li>
</ul></li>
</ul>

<pre class="mermaid">
---
  config:
    layout: elk
---
stateDiagram-v2
    state "TODO MachineDeployment Controller" as MDC {
        [*] --> FetchDeployment
        FetchDeployment --> LogFrozenOrTBD
        LogFrozenOrTBD --> ValidateSpec
        ValidateSpec --> CheckDeletion

        state "GetMachineSets" as GMS {
            [*] --> CreateControllerRefMgr
            CreateControllerRefMgr --> GetControllerRef
            GetControllerRef --> Orphan : Nil<br/>(No Owner)
            GetControllerRef --> CheckUID : Not Nil<br/>(Owner Exists)

            CheckUID --> Ignore : Mismatch<br/>(Wrong Owner)
            CheckUID --> MatchSelector : UID Same
            Orphan --> CheckDelete
            CheckDelete --> SelectorMatch : No Deletion
            SelectorMatch --> AdoptOrphan : Selector Match

            MatchSelector --> KeepClaim : Selector Match<br/>Already Owned
            MatchSelector --> DeletionCheck : Selector Mismatch
            DeletionCheck --> AttemptRelease : No Deletion

            KeepClaim --> AddToClaimed
            AdoptOrphan --> AddToClaimed
            AttemptRelease --> RemoveFromClaimed
        }

        CheckDeletion --> AddFinalizer : No Deletion
        AddFinalizer --> StatusUpdate
        StatusUpdate --> GetMachineSets

        GetMachineSets --> BuildMachineMap<br/>MSetUIDToMachines
        BuildMachineMap<br/>MSetUIDToMachines --> DeleteChk
        DeleteChk --> CheckPausedCond : No Deletion
        DeleteChk --> ProcessDeletion : Deletion Requested

        state "Process Deletion" as DC {
            [*] --> Exit : Finalizer<br/>NotPresent
            [*] --> RemoveFinalizers : NoBackingMS
            [*] --> TerminateMachineSets : BackingMS

            TerminateMachineSets --> SyncStatusOnly<br/>UpdateMcdStatus
            RemoveFinalizers --> Exit
        }

        state "Check Paused Condition" as CPC {
            [*] --> GetCondition<br/>TypeProcessing

            GetCondition<br/>TypeProcessing --> [*] : CondReason<br/>TimeOut
            GetCondition<br/>TypeProcessing --> ExistingPaused : CondReason<br/>Paused
            GetCondition<br/>TypeProcessing --> NotExistingPaused : Else

            NotExistingPaused --> Spec.Paused
            Spec.Paused --> SetPausedCondition : true

            ExistingPaused --> SpecPaused
            SpecPaused --> SetResumedCondition : False

            SetPausedCondition --> UpdateMcdStatus
            SetResumedCondition --> UpdateMcdStatus

            UpdateMcdStatus --> [*]
        }

        CheckPausedCond --> SetPrioAnnotation : TODO

        SetPrioAnnotation --> Sync : Spec.Paused true<br/>TODO
        SetPrioAnnotation --> CheckRollbackTo : Spec.Paused false

        state "Rollback" as RB {
            [*] --> FindRevision
            FindRevision --> FindMatchingMS : RollbackTo.Revision<br/>Present
            FindRevision --> ClearRollbackTo : No last revision

            FindMatchingMS --> Remove<br/>PreferNoSched<br/>Taint : MSRevisionAnnotation<br/>same as<br/>RollbackTo Revision
            FindMatchingMS --> ClearRollbackTo : NoMachineSetFound

            Remove<br/>PreferNoSched<br/>Taint --> UpdateMcdTemplate
            UpdateMcdTemplate --> UpdateMcdAnnotations : Copy MS template<br/>Remove label<br/>machine-template-hash

            UpdateMcdAnnotations --> ClearRollbckTo
            ClearRollbckTo --> EmitRollbackEvent
        }

        CheckRollbackTo --> Rollback : Rollback Requested
        CheckRollbackTo --> IsScalingEvent : No Rollback

        state "Is Scaling Event" as SC {
            [*] --> GetMS<br/>SyncRev
            GetMS<br/>SyncRev --> NotScaling : err
            GetMS<br/>SyncRev --> NotScaling : No New MS

            GetMS<br/>SyncRev --> CheckActiveMS : MS Replicas > 0
            CheckActiveMS --> ScalingEvent : NoActiveMS &<br/>MCD Replicas > 0<br/>(ScaleFromZero)

            CheckActiveMS --> GetMSDesiredReplica<br/>Annotation
            GetMSDesiredReplica<br/>Annotation --> ScalingEvent : Desired not equal<br/>to MCD Replicas

            CheckActiveMS --> NotScaling : NoActiveMS or<br/>Desired = MCD Replicas<br/>(For all active)
        }

        IsScalingEvent --> Sync : Scale Event
        IsScalingEvent --> DeployStrategy : No Scale Event

        state "Sync" as SN {
            [*] --> GetMS<br/>SyncRevision
            GetMS<br/>SyncRevision --> Scale
            Scale --> CleanMCD : Paused and<br/>No RollbackTo
            Scale --> SyncMCDStatus

            state "Find Active or Latest MS" as ALMS {
            [*] --> SortMS by CreationTime<br/>FilterActiveMS
            }

            state "TODO Scale" as SCC {
                state "ReplicasToAdd<br/>AllowedSize - AllMSReplicaCnt" as ReplicasToAdd

                [*] --> GetActiveOrLatestMS
                GetActiveOrLatestMS --> CheckActiveMSReplicas : not nil
                GetActiveOrLatestMS --> CheckNewMS<br/>Saturated

                CheckActiveMSReplicas --> FIXME : ActiveMSRep = mcdRep

                CheckNewMS<br/>Saturated --> ScaleDownOldMS : true
                CheckNewMS<br/>Saturated --> IsRollingUpdate : false

                IsRollingUpdate --> FilterActiveMS : true
                FilterActiveMS --> GetReplicaCount<br/>AllMS

                GetReplicaCount<br/>AllMS --> FindAllowedSize

                FindAllowedSize --> Zero : MCD Replicas <= 0
                FindAllowedSize --> McdReplicas+MaxSurge : MCD Replicas > 0

                Zero --> ReplicasToAdd
                McdReplicas+MaxSurge --> ReplicasToAdd

                ReplicasToAdd --> ScaleUp : more than 0
                ReplicasToAdd --> ScaleDown : < 0

                ScaleUp --> map[name]=NewRep : oldMS = Replicas
                ScaleUp --> map[name]=NewRep : newMS = Rep+RepToAdd

            }
        }

        state "TODO DeployStrategy" as DS {
            state "Recreate" as RC {
                [*] --> OldScaleDown
                OldScaleDown --> CreateNew
                CreateNew --> NewScaleUp
            }

            state "RollingUpdate" as RU {
                [*] --> ScaleUpNew
                [*] --> ScaleDownOld
                ScaleDownOld --> CleanupOld
            }
        }

        DeployStrategy --> UpdateStatus
        UpdateStatus --> [*]
    }

</pre>
</div>
</div>
<div id="outline-container-org59125ff" class="outline-2">
<h2 id="org59125ff">Summary</h2>
<div class="outline-text-2" id="text-org59125ff">
<p>Each of these controllers implements sophisticated error handling and retry mechanisms:
</p>
<ol class="org-ol">
<li>Error Handling:
<ul class="org-ul">
<li>Categorizes errors into recoverable and non-recoverable</li>
<li>Implements exponential backoff for retries</li>
<li>Maintains error counters and conditions</li>
<li>Updates status to reflect error states</li>
</ul></li>

<li>Resource Protection:
<ul class="org-ul">
<li>Uses finalizers to prevent premature deletion</li>
<li>Implements owner references for proper garbage collection</li>
<li>Maintains consistent state through careful status updates</li>
<li>Handles race conditions through proper locking</li>
</ul></li>

<li>Performance Considerations:
<ul class="org-ul">
<li>Implements work queues for efficient processing</li>
<li>Uses informers for efficient cache handling</li>
<li>Batches operations when possible</li>
<li>Implements rate limiting for API calls</li>
</ul></li>

<li>Monitoring and Metrics:
<ul class="org-ul">
<li>Tracks operation durations</li>
<li>Records error counts and types</li>
<li>Provides health metrics</li>
<li>Implements proper logging for debugging</li>
</ul></li>
</ol>

<p>The entire system works together to provide:
</p>
<ol class="org-ol">
<li>Reliable machine lifecycle management</li>
<li>Proper cleanup of resources</li>
<li>Scaling capabilities</li>
<li>Rolling updates and rollbacks</li>
<li>Protection against race conditions and API server issues</li>
<li>Efficient resource utilization</li>
<li>Proper monitoring and debugging capabilities</li>
</ol>

<p>This comprehensive system ensures robust machine management while maintaining high availability and proper resource utilization. The controllers work together to maintain the desired state while handling various edge cases and failure scenarios.
</p>
</div>
</div>
</div>
<footer id="postamble" class="status">
&copy; 2026 . Made with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 31.0.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11).
</footer>
</body>
</html>
