<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2026 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IUSACO</title>
<meta name="author" content="Tak" />
<meta name="generator" content="Org Mode" />
<script src='/css/head.js'></script> <link rel='stylesheet' type='text/css' href='/css/stylesheet.css'>

<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css' integrity='sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC' crossorigin='anonymous'>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js' integrity='sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja' crossorigin='anonymous'></script>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js' integrity='sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR' crossorigin='anonymous'></script>
<script defer>
document.addEventListener('DOMContentLoaded', function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
    });
});
</script>
</head>
<body>
<div id="nav" class="status">
<a href='/'>bacchanalian madness</a> / <a href='/rss'>rss</a> / <label id='dark-mode-button'> <input type='checkbox'> </label>
</div>
<div id="content" class="content">
<header>
<h1 class="title">IUSACO</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgefdc361">Input and Output</a></li>
<li><a href="#org5c5c970">Complexity and algorithm analysis</a></li>
<li><a href="#org6539119">Built-in Data Structures</a></li>
<li><a href="#orgea48c97">Elementary Techniques</a></li>
<li><a href="#orgd4b5eeb">Graph Theory</a></li>
<li><a href="#org7e53fa1">More Techniques</a></li>
<li><a href="#orgb88675a">Additional Topics</a></li>
</ul>
</div>
</nav>
<p>CLOSED: <span class="timestamp-wrapper"><span class="timestamp">[2022-06-05 Sun]</span></span>
</p>
<div id="outline-container-orgefdc361" class="outline-2">
<h2 id="orgefdc361">Input and Output</h2>
<div class="outline-text-2" id="text-orgefdc361">
<div class="org-src-container">
<pre class="src src-cpp">#include &lt;cstdio&gt;
using namespace std;
int main() {
    freopen("template.in", "r", stdin);
    freopen("template.out", "w", stdout);
}
</pre>
</div>
<ul class="org-ul">
<li>When using C++, arrays should be declared globally, or initialized to zeros if declared locally to avoid garbage values.</li>
<li>32bit int: \(\pm 2\times10^{9}\) v/s 64bit int: \(\pm 9\times 10^{18}\)</li>
</ul>
</div>
</div>
<div id="outline-container-org5c5c970" class="outline-2">
<h2 id="org5c5c970">Complexity and algorithm analysis</h2>
<div class="outline-text-2" id="text-org5c5c970">
<ul class="org-ul">
<li>Elementary mathematical calculation: O(1)</li>
<li>Unordered set/map: O(1) per operation</li>
<li>Binary Search: O(log n)</li>
<li>Ordered set/map or Priority Queue: O(log n) per operation</li>
<li>Prime factorization or primality check for int: \(O(\sqrt{n})\)</li>
<li>Reading n inputs: O(n)</li>
<li>Iterating through n element array: O(n)</li>
<li>Sorting: Usually O(n log n) for <code>std::sort()</code></li>
<li>Iterating through all subsets of size k of input elements: O(\(n^{k}\) ), for triplets O(\(n^{3}\))</li>
<li>Iterating through all subsets: O(\(2^{n}\))</li>
<li>Iterating through all permutations: O(n!)</li>
</ul>
</div>
</div>
<div id="outline-container-org6539119" class="outline-2">
<h2 id="org6539119">Built-in Data Structures</h2>
<div class="outline-text-2" id="text-org6539119">
<p>Data Structure determines how data is stored, each supports some operations efficiently. In following discussion, desired data type is put between <code>&lt;&gt;</code>. Most std structures support <code>size()</code> and <code>empty()</code> methods.
</p>
</div>
<div id="outline-container-org735d24c" class="outline-3">
<h3 id="org735d24c">Iterators</h3>
<div class="outline-text-3" id="text-org735d24c">
<p>Allows for traversal of a container with the help of a pointer.
</p>
<div class="org-src-container">
<pre class="src src-cpp">for (vector&lt;int&gt;::iterator it = myvector.begin(); it != myvector.end(); ++it) {
  cout &lt;&lt; *it; //prints the values in the vector using the pointer
}
</pre>
</div>

<p>Alternate way to achieve the same with a for-each loop and <code>auto</code>.
</p>
<div class="org-src-container">
<pre class="src src-cpp">for(auto element : v){
  cout &lt;&lt; element; // prints values in vector
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org105f99b" class="outline-3">
<h3 id="org105f99b">Dynamic Arrays</h3>
<div class="outline-text-3" id="text-org105f99b">
<p>Addition and deletion at the end in O(1) time and in the middle in O(n) time.
</p>
<div class="org-src-container">
<pre class="src src-cpp">vector&lt;int&gt; v;
for(int i = 1; i &lt;= 10; i++){
  v.push_back(i); // stores 1 to 10 in a dynamic array
}
</pre>
</div>

<p>Vectors can be made static sized by initializing it with a size, <code>vector&lt;int&gt; v(30);</code>. They also support an <code>v.erase()</code> operation. A dynamic array can be sorted (default ascending) by <code>sort(v.begin(), v.end())</code>.
</p>
</div>
</div>
<div id="outline-container-org7ab2907" class="outline-3">
<h3 id="org7ab2907">Stacks and Queues</h3>
<div class="outline-text-3" id="text-org7ab2907">
<p><b>Stacks</b>: LIFO with operations <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) all of which are O(1). Declared as <code>stack&lt;int&gt; s</code>.
</p>

<p><b>Queues</b>: FIFO with operations <code>push</code> (add in front), <code>pop</code> (remove at end) and <code>front</code> (show end) in O(1).
</p>

<p><b>Deques</b>: Combination of a stack and a queue supporting insertion and deletion from both front and end. Operations are aptly named as <code>push_back</code>, <code>push_font</code>, <code>pop_back</code> and <code>pop_front</code>.
</p>

<p><b>Priority Queues</b>: Supports insertion of elements and deletion and retrieval of element <i>with highest priority</i> in O(log n) where priority is based on a comparator function (highest element in front). Has <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) operations and is declared as <code>priority_queue&lt;int&gt; pq;</code>.
</p>
</div>
</div>
<div id="outline-container-orgb0d9b0a" class="outline-3">
<h3 id="orgb0d9b0a">Sets</h3>
<div class="outline-text-3" id="text-orgb0d9b0a">
<p>A <i>set</i> is a collection of objects having no duplicates.
</p>

<p><b>Unordered Sets</b>: Work by hashing that is, assigning a unique code to every object allowing for <code>insert</code>, <code>erase</code> and <code>count</code> (set contains element then 1 else 0) in O(1). Traversal is pointless. Declared as <code>unordered_set&lt;int&gt; s</code>.
</p>

<div class="org-src-container">
<pre class="src src-cpp">for(int element : s){
  cout &lt;&lt; element &lt;&lt; " "; // iterating through a set, arbitrary order
}
</pre>
</div>

<p><b>Ordered Sets</b>: Insertion, deletion and search needs O(log n) time. Has additional operations <code>begin()</code> (iterator to lowest element), <code>end()</code>, <code>lower_bound()</code> (iterator to least element &ge; some k) and <code>upper_bound()</code>.
</p>

<p><b>Multisets</b>: A sorted set allowing multiple copies of same element, whose <code>count</code> operation returns the number of times an element is present in set. Time complexity of this operation is O(log n + f) where <i>log n</i> factor searches for element and <i>f</i> factor iterates through sorted set to get count. Declared as <code>multiset&lt;int&gt; ms</code>.
</p>
</div>
</div>
<div id="outline-container-org6d4e308" class="outline-3">
<h3 id="org6d4e308">Maps</h3>
<div class="outline-text-3" id="text-org6d4e308">
<p>A <i>map</i> is a set of <i>ordered pairs</i> called key and value where keys must be unique but values can be repeated. Supported operations are addition and removal of key-value pair and <i>retrieval</i> of values for a given key. Unordered maps perform aforementioned methods in O(1) whereas for ordered maps it's O(log n), sorted in order of key.
</p>

<p><b>Unordered Maps</b>: In map <code>m</code>, <code>m[key] = value</code> operator assigns value to a key and places the pair on the map, <code>m[key]</code> returns value associated with the key, <code>count(key)</code> checks for existence of key in the map and <code>erase(it)</code> removes pair associated with a key or iterator. Declared as <code>unordered_map&lt;int, int&gt; m</code>.
</p>

<p><b>Ordered Maps</b>: Supports additional operations <code>lower_bound</code> and <code>upper_bound</code> which return iterators pointing to lowest entry not less than/ strictly greater than a specified key.
</p>

<div class="org-src-container">
<pre class="src src-cpp">map&lt;int, int&gt; m; // [(3,5); (11,4)]
m[10] = 491; // [(3,5); (10,491); (11,4)]
cout &lt;&lt; m.lower_bound(10)-&gt;first &lt;&lt; " " &lt;&lt; m.lower_bound(10)-&gt;second &lt;&lt; "\n";
// 10 491
cout &lt;&lt; m.upper_bound(10)-&gt;first &lt;&lt; " " &lt;&lt; m.upper_bound(10)-&gt;second &lt;&lt; "\n";
// 11 4
m.erase(11); // [(3,5); (10,491)]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgea48c97" class="outline-2">
<h2 id="orgea48c97">Elementary Techniques</h2>
<div class="outline-text-2" id="text-orgea48c97">
</div>
<div id="outline-container-org2dba3d1" class="outline-3">
<h3 id="org2dba3d1">Simulation</h3>
<div class="outline-text-3" id="text-org2dba3d1">
<p>Simulation refers to the act of doing precisely what the problem statement states and nothing else; essentially simulating it.
</p>
</div>
</div>
<div id="outline-container-org9d8758c" class="outline-3">
<h3 id="org9d8758c">Complete Search</h3>
<div class="outline-text-3" id="text-org9d8758c">
<p>Brute forcing through all the possible cases in solution space to arrive at the solution. To iterate through all permutations of a list:
</p>
<div class="org-src-container">
<pre class="src src-cpp">do {
  check(v); // process or check the current permutation for validity
} while(next_permutation(v.begin(), v.end()));
</pre>
</div>
</div>
</div>
<div id="outline-container-org96582ea" class="outline-3">
<h3 id="org96582ea">Sorting and Comparators</h3>
<div class="outline-text-3" id="text-org96582ea">
<p>C++ has built-in function for sorting in ascending order: <code>std::sort(arr, arr+N)</code> or for a vector <code>sort(v.begin(), v.end())</code>. For sorting in a self-defined order, one must use a custom comparator.
</p>
</div>
</div>
<div id="outline-container-org0f1a29f" class="outline-3">
<h3 id="org0f1a29f">Greedy Algorithms</h3>
<div class="outline-text-3" id="text-org0f1a29f">
<p>Algorithms that select the most optimal choice at each step, instead of looking at the solution space as a whole. Usually in a greedy algorithm, there is a heuristic or value function that determines which choice is considered most optimal. The choice of the greedy algorithm matters too, for example in a scheduling problem choosing earliest starting next event would be incorrect, instead one should go for earliest ending next event because that would give one more choices for future events.
</p>

<p>Greedy won't work in all scenarios though, for example in the fairly popular coin change problem, if the denominations are <code>{1,3,4}</code> then greedy solution would be <code>{4,1,1}</code> but the correct least amount of coins would be two <code>{3,3}</code>. Similarly it cannot work for the knapsack problem which is solved using Dynamic Programming.
</p>
</div>
</div>
</div>
<div id="outline-container-orgd4b5eeb" class="outline-2">
<h2 id="orgd4b5eeb">Graph Theory</h2>
<div class="outline-text-2" id="text-orgd4b5eeb">
</div>
<div id="outline-container-org2573b38" class="outline-3">
<h3 id="org2573b38">Representation</h3>
<div class="outline-text-3" id="text-org2573b38">
<p>Graphs (N vertices and M edges) are usually given in the format: <code>N</code> <code>M</code> followed by the <code>M edges</code> each showing the connecting vertices. One thing to note is that a graph should be stored globally and statically, for access outside the main method. A graph can be represented in three ways:
</p>
</div>
<div id="outline-container-org28fdd30" class="outline-4">
<h4 id="org28fdd30">Adjacency List</h4>
<div class="outline-text-4" id="text-org28fdd30">
<p>For using DFS, BFS, Dijkstra or other <code>single-source</code> traversal algorithms, it's the preferred way of storing graphs. In it, an array of length N of lists is maintained.
<img src="/assets/usaco-adj.png" alt="usaco-adj.png">
They take up <code>O(M+N)</code> space but allow for easy traversal among the neighbors of a vertex. Often, there's a need to maintain a <code>visited</code> array.
</p>
<div class="org-src-container">
<pre class="src src-cpp">int n, m;
vector&lt;int&gt; adj[MAXN];
bool visited[MAXN];

int main(){
  cin &gt;&gt; n &gt;&gt; m;
  for(int i = 0; i &lt; m; i++){
    int a, b;
    cin &gt;&gt; a &gt;&gt; b;
    a--; b--; // subtract 1 for vertex since array is zero-indexed
    adj[a].push_back(b);
    adj[b].push_back(a); // omit for directed graph
  }
}

// For a weighted graph:
struct Edge
{
  int to, weight;
  Edge(int dest, int w):
  to(dest), weight(w)
  {
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2a5ccb7" class="outline-4">
<h4 id="org2a5ccb7">Adjacency Matrix</h4>
<div class="outline-text-4" id="text-org2a5ccb7">
<p>This is an <code>N x N</code> 2D array that stores for each pair of indices(a,b) whether an edge exists between them or not. Primarily used for Floyd-Warshall Algorithm.
</p>
<div class="org-src-container">
<pre class="src src-cpp">int n, m;
int adj[MAXN][MAXN];

int main(){
  cin &gt;&gt; n &gt;&gt; m;
  for(int i = 0; i &lt; m; i++){
    int a, b;
    cin &gt;&gt; a &gt;&gt; b;
    a--; b--;
    adj[a][b] = 1; // or w for weighted graph
    adj[b][a] = 1; // ignore this if directed
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb27e759" class="outline-4">
<h4 id="orgb27e759">Edge List</h4>
<div class="outline-text-4" id="text-orgb27e759">
<p>Usually used for weighted undirected graphs when sorting the edges by weight is needed (DSU). Its simply a single list of all edges <code>(a, b, w)</code> where a and b are the vertices and w is the weight of connecting edge. Each edge is added only oncce.
</p>
<div class="org-src-container">
<pre class="src src-cpp">struct Edge{
  int a, b, w;
  Edge(int start, int end, int weight):
  a(start), b(end), w(weight)
  {
  }
  bool operator&lt;(const Edge &amp; e)
  const{
    return w &lt; e.w; // ascending weight sort
  }
};

int n, m;
vector&lt;Edge&gt; edges;

int main(){
  cin &gt;&gt; n &gt;&gt; m;
  for(int i = 0; i &lt; m; i++){
    int a, b, w;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
    a--; b--;
    edges.push_back(Edge(a, b, w)); // add edge to list
  }
  sort(edges.begin(), edges.end());
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9df9fca" class="outline-3">
<h3 id="org9df9fca">Traversal</h3>
<div class="outline-text-3" id="text-org9df9fca">
</div>
<div id="outline-container-orgf0cd28f" class="outline-4">
<h4 id="orgf0cd28f">Breadth-First Search (BFS)</h4>
<div class="outline-text-4" id="text-orgf0cd28f">
<p>Visits nodes in order of distance away from the starting node; first visit nodes that are one edge away then those that are two edges away and so on. It can be used for finding the distance from a starting node to all nodes in an unweighted graph.
</p>
<div class="org-src-container">
<pre class="src src-cpp">void bfs(int start){
  const int total_nodes = n;
  memset(dist, -1, sizeof dist); // fill distance array with -1s
  queue&lt;int&gt; q;
  dist[start] = 0;
  q.push(start);
  int seen = 1;
  while(!q.empty()){
    int v = q.front();
    q.pop();
    for(int e: adj[v]){
      if(dist[e] == -1){
        dist[e] = dist[v] + 1;
        if(++seen == total_nodes) break; // see: https://observablehq.com/@yurivish/efficient-graph-search
        q.push(e);
      }
    }
  }
}
</pre>
</div>
<p>Once BFS finishes, the array <code>dist</code> contains the distances from the start node to each node.
</p>
</div>
</div>
<div id="outline-container-orgb4612c9" class="outline-4">
<h4 id="orgb4612c9">Depth-First Search (DFS)</h4>
<div class="outline-text-4" id="text-orgb4612c9">
<p>Continues down a single path as far as possible until it has no more vertices to visit along that path, then backtracks and finds more vertices to visit.
</p>
<div class="org-src-container">
<pre class="src src-cpp">void dfs(int node){
  visited[node] = true;
  for(int next : adj[node]){
    if(!visited[next]){
      dfs(next);
    }
  }
}
</pre>
</div>
<p>If stack overflows are encountered with recursive DFS, it can be implemented iteravely by storing nodes in the BFS implementation on a stack instead of a queue.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfce8b80" class="outline-3">
<h3 id="orgfce8b80">Floodfill</h3>
<div class="outline-text-3" id="text-orgfce8b80">
<p>Its DFS but on a grid and the aim is to find the connected component of all the connected cells with the same number. As opposed to an explicit graph where the edges are given, a grid is an implicit graph where the neighbours are nodes adjacent in the four directions.
</p>

<p>When doing floodfill, an <code>N x M</code> array of bools <code>visited</code> is maintained and a global variable for the size of currently visiting component. The search function is called recursively from squares on all four sides of the current one.
</p>
<div class="org-src-container">
<pre class="src src-cpp">int grid[MAXN][MAXM];
int n, m;
bool visited[MAXN][MAXM];
int currentCompSize = 0;

void floodfill(int r, int c, int color){
  if(r &lt; 0 || r &gt;= n || c &lt; 0 || c &gt;= m) return; // outside grid
  if(grid[r][c] != color) return; // wrong color
  if(visited[r][c]) return; // already visited

  visited[r][c] = true; // mark current sq as visited
  currentCompSize++;
  // recursively call floodfill for neighbour sqs
  floodfill(r, c+1, color);
  floodfill(r, c-1, color);
  floodfill(r-1, c, color);
  floodfill(r+1, c, color);
}

int main(){
  /*
   * additional stuff here
  */
  for(int i = 0; i &lt; n; i++){
    for(int j = 0; j &lt; m; j++){
      if(!visited[i][j]){
        currentCompSize = 0;
        floodfill(i, j, grid[i][j]);
      }
    }
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd81080" class="outline-3">
<h3 id="orgfd81080">Disjoint-Set Union Data Structure</h3>
<div class="outline-text-3" id="text-orgfd81080">
<p>It supports two operations:
</p>
<ul class="org-ul">
<li>Add an edge between two nodes</li>
<li>Check if two nodes are connected</li>
</ul>
<p>For this, the sets are stored as trees; initially each node is its own set then the sets are combined when an edge is added between two nodes.
</p>
<div class="org-src-container">
<pre class="src src-cpp">int parent[MAXN]; // store root of each set

void initialize(int N){
  for(int i = 0; i &lt; N; i++)
    parent[i] = i; // initially, root of each set is node itself
}

int find(int x){ // find root of set of x
  if(x == parent[x])
    return x; // if x is its parent, it is the root
  else
    return find(parent[x]);
}

void union(int a, int b){ // merge sets of a and b
  int c = find(a);        // find a's root
  int d = find(b);        // find b's root
  if (c != d)
    parent[d] = c;        // merge sets by setting parent of d to c
}
</pre>
</div>
<p>The naive recursive implementation of find can be improved from <code>O(nm)</code> by path compression; the idea being reassignment of nodes on recursive calls to <code>find</code> to prevent formation of long chains and the runtime becomes <code>O(n log n)</code>.
</p>
<div class="org-src-container">
<pre class="src src-cpp">int find(int x){
  if(x == parent[x])
    return x;
  else
    return parent[x] = find(parent[x]);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org28ec322" class="outline-3">
<h3 id="org28ec322">Miscellaneous</h3>
<div class="outline-text-3" id="text-org28ec322">
<ul class="org-ul">
<li>DAGs (Directed Acyclic graphs) by virtue of not having any cycles allows them to have an ordering of nodes such that for any edge from <i>u</i> to <i>v</i>, <i>u</i> appears before <i>v</i> (topological sorting).</li>
<li>Bipartite graph is such that each node can only be colored by 2 colors such that no adjacent nodes share the same colour. A graph is bipartite iff there are no cycles of odd length. A modified BFS can be use to check whether a graph is bipartite or not.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7e53fa1" class="outline-2">
<h2 id="org7e53fa1">More Techniques</h2>
<div class="outline-text-2" id="text-org7e53fa1">
</div>
<div id="outline-container-orgee59163" class="outline-3">
<h3 id="orgee59163">Prefix Sums</h3>
<div class="outline-text-3" id="text-orgee59163">
<p>To process queries to find the sum of elements between two indices in a list, prefix sum is useful. Using 1-index in the array is beneficial i.e. assigning <code>arr[0] = 0</code> and hence <code>prefix[0] = 0</code>.
</p>

<p>\(prefix[k] = \sum_{i=1}^{k}arr[i] = prefix[k-1] + arr[k]\)
</p>

<p>For processing Q queries consisting on an array of N elements, the complexity is <code>O(N+Q)</code>.
</p>

<div class="note" id="orge7672c0">
<p>TODO: DP, 2D prefix sum as 1-D only
</p>

</div>
</div>
</div>
<div id="outline-container-orga365cad" class="outline-3">
<h3 id="orga365cad">Binary Search</h3>
</div>
<div id="outline-container-org77ada59" class="outline-3">
<h3 id="org77ada59">Basic Number Theory</h3>
<div class="outline-text-3" id="text-org77ada59">
<p>Prime factorization of a number is computed by this algorithm in \(O(\sqrt{n})\):
<img src="/assets/usaco-pf.png" alt="usaco-pf.png">
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">i</th>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">v</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-right">252</td>
<td class="org-left">{}</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">126</td>
<td class="org-left">{2}</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">63</td>
<td class="org-left">{2,2}</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">21</td>
<td class="org-left">{2,2,3}</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
<td class="org-left">{2,2,3,3}</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">1</td>
<td class="org-left">{2,2,3,3,7}</td>
</tr>
</tbody>
</table>
<p>GCD using Euclidean Algorithm in <code>O(log min(a,b))</code>:
</p>
<div class="org-src-container">
<pre class="src src-cpp">int gcd(int a, int b){
  if(!b) return a;
  return gcd(b, a%b);
}
</pre>
</div>
<p>LCM can be computed using GCD by \(\frac{a \times b}{gcd(a,b)}\)
</p>

<p>Modular Arithmetic is useful for dealing with overflows by taking remainders:
</p>

<p>\[\begin{align*}
(a \pm b)\mod m &= (a\mod m \pm b\mod m)\mod m \\
(a \times b)\mod m &= ((a\mod m) \times (b\mod m))\mod m \\
a^{b}\mod m &= (a\mod m)^{b}\mod m
\end{align*}\]
</p>
</div>
</div>
</div>
<div id="outline-container-orgb88675a" class="outline-2">
<h2 id="orgb88675a">Additional Topics</h2>
<div class="outline-text-2" id="text-orgb88675a">
<ul class="org-ul">
<li>Two Pointers <br>
Iterate across an array that track the start and end of an interval or values in a sorted array. Both pointers are monotonic i.e. start at one end of array and move in only one direction.</li>
</ul>
</div>
<div id="outline-container-org96a2bef" class="outline-3">
<h3 id="org96a2bef">Line Sweep</h3>
</div>
<div id="outline-container-org3f74666" class="outline-3">
<h3 id="org3f74666">Bitwise Operations</h3>
</div>
<div id="outline-container-orgc9d7d7d" class="outline-3">
<h3 id="orgc9d7d7d">Ad-hoc</h3>
</div>
</div>
</div>
<footer id="postamble" class="status">
&copy; 2026 . Made with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 31.0.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11).
</footer>
</body>
</html>
