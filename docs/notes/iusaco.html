<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2026 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IUSACO</title>
<meta name="author" content="Tak" />
<meta name="generator" content="Org Mode" />
<script src='/css/head.js'></script> <link rel='stylesheet' type='text/css' href='/css/stylesheet.css'>

<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css' integrity='sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC' crossorigin='anonymous'>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js' integrity='sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja' crossorigin='anonymous'></script>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js' integrity='sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR' crossorigin='anonymous'></script>
<script defer>
document.addEventListener('DOMContentLoaded', function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
    });
});
</script>
</head>
<body>
<div id="nav" class="status">
<a href='/'>bacchanalian madness</a><a href='/rss.xml'>
    <button id='rss-button' aria-label='Get RSS feed' type='button'>
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 448 512' fill='currentColor'>
        <path d='M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z'></path>
      </svg>
    </button>
  </a><button id='dark-mode-button' aria-label='Toggle Dark Mode' type='button'>
    <svg id='moon-icon' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'>
      <path d='M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z'></path>
    </svg>
    <svg id='sun-icon' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor' style='display: none;'>
      <path d='M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z' fill-rule='evenodd' clip-rule='evenodd'></path>
    </svg>
  </button>
</div>
<div id="content" class="content">
<header>
<h1 class="title">IUSACO</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org66989b9">Input and Output</a></li>
<li><a href="#org2b1ecc7">Complexity and algorithm analysis</a></li>
<li><a href="#orgbebd52c">Built-in Data Structures</a></li>
<li><a href="#orgbf0fa44">Elementary Techniques</a></li>
<li><a href="#orgdd63b05">Graph Theory</a></li>
<li><a href="#org16e2e0d">More Techniques</a></li>
<li><a href="#orgeee903e">Additional Topics</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org66989b9" class="outline-2">
<h2 id="org66989b9">Input and Output</h2>
<div class="outline-text-2" id="text-org66989b9">
<pre class="src src-c++"><code><span class="font-lock-preprocessor-face">  #include</span> <span class="font-lock-string-face">&lt;cstdio&gt;</span>
  <span class="font-lock-keyword-face">using</span> <span class="font-lock-keyword-face">namespace</span> <span class="font-lock-constant-face">std</span>;
  <span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>() {
      freopen(<span class="font-lock-string-face">"template.in"</span>, <span class="font-lock-string-face">"r"</span>, stdin);
      freopen(<span class="font-lock-string-face">"template.out"</span>, <span class="font-lock-string-face">"w"</span>, stdout);
  }</code></pre>
<ul class="org-ul">
<li>When using C++, arrays should be declared globally, or initialized to zeros if declared locally to avoid garbage values.</li>
<li>32bit int: \(\pm 2\times10^{9}\) v/s 64bit int: \(\pm 9\times 10^{18}\)</li>
</ul>
</div>
</div>
<div id="outline-container-org2b1ecc7" class="outline-2">
<h2 id="org2b1ecc7">Complexity and algorithm analysis</h2>
<div class="outline-text-2" id="text-org2b1ecc7">
<ul class="org-ul">
<li>Elementary mathematical calculation: O(1)</li>
<li>Unordered set/map: O(1) per operation</li>
<li>Binary Search: O(log n)</li>
<li>Ordered set/map or Priority Queue: O(log n) per operation</li>
<li>Prime factorization or primality check for int: \(O(\sqrt{n})\)</li>
<li>Reading n inputs: O(n)</li>
<li>Iterating through n element array: O(n)</li>
<li>Sorting: Usually O(n log n) for <code>std::sort()</code></li>
<li>Iterating through all subsets of size k of input elements: O(\(n^{k}\) ), for triplets O(\(n^{3}\))</li>
<li>Iterating through all subsets: O(\(2^{n}\))</li>
<li>Iterating through all permutations: O(n!)</li>
</ul>
</div>
</div>
<div id="outline-container-orgbebd52c" class="outline-2">
<h2 id="orgbebd52c">Built-in Data Structures</h2>
<div class="outline-text-2" id="text-orgbebd52c">
<p>Data Structure determines how data is stored, each supports some operations efficiently. In following discussion, desired data type is put between <code>&lt;&gt;</code>. Most std structures support <code>size()</code> and <code>empty()</code> methods.
</p>
</div>
<div id="outline-container-orgd86bbf4" class="outline-3">
<h3 id="orgd86bbf4">Iterators</h3>
<div class="outline-text-3" id="text-orgd86bbf4">
<p>Allows for traversal of a container with the help of a pointer.
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">for</span> (<span class="font-lock-constant-face">vector</span>&lt;<span class="font-lock-type-face">int</span>&gt;::<span class="font-lock-type-face">iterator</span> <span class="font-lock-variable-name-face">it</span> = myvector.begin(); it != myvector.end(); ++it) {
  cout &lt;&lt; *it; <span class="font-lock-comment-delimiter-face">//</span><span class="font-lock-comment-face">prints the values in the vector using the pointer
</span>}</code></pre>

<p>Alternate way to achieve the same with a for-each loop and <code>auto</code>.
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">for</span>(<span class="font-lock-keyword-face">auto</span> <span class="font-lock-variable-name-face">element</span> : v){
  cout &lt;&lt; element; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">prints values in vector
</span>}</code></pre>
</div>
</div>
<div id="outline-container-orga29ae00" class="outline-3">
<h3 id="orga29ae00">Dynamic Arrays</h3>
<div class="outline-text-3" id="text-orga29ae00">
<p>Addition and deletion at the end in O(1) time and in the middle in O(n) time.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">vector</span>&lt;<span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">v</span>;
<span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 1; i &lt;= 10; i++){
  v.push_back(i); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">stores 1 to 10 in a dynamic array
</span>}</code></pre>

<p>Vectors can be made static sized by initializing it with a size, <code>vector&lt;int&gt; v(30);</code>. They also support an <code>v.erase()</code> operation. A dynamic array can be sorted (default ascending) by <code>sort(v.begin(), v.end())</code>.
</p>
</div>
</div>
<div id="outline-container-org193fb17" class="outline-3">
<h3 id="org193fb17">Stacks and Queues</h3>
<div class="outline-text-3" id="text-org193fb17">
<p><b>Stacks</b>: LIFO with operations <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) all of which are O(1). Declared as <code>stack&lt;int&gt; s</code>.
</p>

<p><b>Queues</b>: FIFO with operations <code>push</code> (add in front), <code>pop</code> (remove at end) and <code>front</code> (show end) in O(1).
</p>

<p><b>Deques</b>: Combination of a stack and a queue supporting insertion and deletion from both front and end. Operations are aptly named as <code>push_back</code>, <code>push_font</code>, <code>pop_back</code> and <code>pop_front</code>.
</p>

<p><b>Priority Queues</b>: Supports insertion of elements and deletion and retrieval of element <i>with highest priority</i> in O(log n) where priority is based on a comparator function (highest element in front). Has <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) operations and is declared as <code>priority_queue&lt;int&gt; pq;</code>.
</p>
</div>
</div>
<div id="outline-container-org6c91716" class="outline-3">
<h3 id="org6c91716">Sets</h3>
<div class="outline-text-3" id="text-org6c91716">
<p>A <i>set</i> is a collection of objects having no duplicates.
</p>

<p><b>Unordered Sets</b>: Work by hashing that is, assigning a unique code to every object allowing for <code>insert</code>, <code>erase</code> and <code>count</code> (set contains element then 1 else 0) in O(1). Traversal is pointless. Declared as <code>unordered_set&lt;int&gt; s</code>.
</p>

<pre class="src src-c++"><code><span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">element</span> : s){
  cout &lt;&lt; element &lt;&lt; <span class="font-lock-string-face">" "</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">iterating through a set, arbitrary order
</span>}</code></pre>

<p><b>Ordered Sets</b>: Insertion, deletion and search needs O(log n) time. Has additional operations <code>begin()</code> (iterator to lowest element), <code>end()</code>, <code>lower_bound()</code> (iterator to least element &ge; some k) and <code>upper_bound()</code>.
</p>

<p><b>Multisets</b>: A sorted set allowing multiple copies of same element, whose <code>count</code> operation returns the number of times an element is present in set. Time complexity of this operation is O(log n + f) where <i>log n</i> factor searches for element and <i>f</i> factor iterates through sorted set to get count. Declared as <code>multiset&lt;int&gt; ms</code>.
</p>
</div>
</div>
<div id="outline-container-orgb2da92e" class="outline-3">
<h3 id="orgb2da92e">Maps</h3>
<div class="outline-text-3" id="text-orgb2da92e">
<p>A <i>map</i> is a set of <i>ordered pairs</i> called key and value where keys must be unique but values can be repeated. Supported operations are addition and removal of key-value pair and <i>retrieval</i> of values for a given key. Unordered maps perform aforementioned methods in O(1) whereas for ordered maps it&rsquo;s O(log n), sorted in order of key.
</p>

<p><b>Unordered Maps</b>: In map <code>m</code>, <code>m[key] = value</code> operator assigns value to a key and places the pair on the map, <code>m[key]</code> returns value associated with the key, <code>count(key)</code> checks for existence of key in the map and <code>erase(it)</code> removes pair associated with a key or iterator. Declared as <code>unordered_map&lt;int, int&gt; m</code>.
</p>

<p><b>Ordered Maps</b>: Supports additional operations <code>lower_bound</code> and <code>upper_bound</code> which return iterators pointing to lowest entry not less than/ strictly greater than a specified key.
</p>

<pre class="src src-c++"><code><span class="font-lock-type-face">map</span>&lt;<span class="font-lock-type-face">int</span>, <span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">m</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">[(3,5); (11,4)]
</span>m[10] = 491; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">[(3,5); (10,491); (11,4)]
</span>cout &lt;&lt; m.lower_bound(10)-&gt;first &lt;&lt; <span class="font-lock-string-face">" "</span> &lt;&lt; m.lower_bound(10)-&gt;second &lt;&lt; <span class="font-lock-string-face">"\n"</span>;
<span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">10 491
</span>cout &lt;&lt; m.upper_bound(10)-&gt;first &lt;&lt; <span class="font-lock-string-face">" "</span> &lt;&lt; m.upper_bound(10)-&gt;second &lt;&lt; <span class="font-lock-string-face">"\n"</span>;
<span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">11 4
</span>m.erase(11); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">[(3,5); (10,491)]</span></code></pre>
</div>
</div>
</div>
<div id="outline-container-orgbf0fa44" class="outline-2">
<h2 id="orgbf0fa44">Elementary Techniques</h2>
<div class="outline-text-2" id="text-orgbf0fa44">
</div>
<div id="outline-container-org7a95247" class="outline-3">
<h3 id="org7a95247">Simulation</h3>
<div class="outline-text-3" id="text-org7a95247">
<p>Simulation refers to the act of doing precisely what the problem statement states and nothing else; essentially simulating it.
</p>
</div>
</div>
<div id="outline-container-orge8c4099" class="outline-3">
<h3 id="orge8c4099">Complete Search</h3>
<div class="outline-text-3" id="text-orge8c4099">
<p>Brute forcing through all the possible cases in solution space to arrive at the solution. To iterate through all permutations of a list:
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">do</span> {
  check(v); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">process or check the current permutation for validity
</span>} <span class="font-lock-keyword-face">while</span>(next_permutation(v.begin(), v.end()));</code></pre>
</div>
</div>
<div id="outline-container-org4eb1f64" class="outline-3">
<h3 id="org4eb1f64">Sorting and Comparators</h3>
<div class="outline-text-3" id="text-org4eb1f64">
<p>C++ has built-in function for sorting in ascending order: <code>std::sort(arr, arr+N)</code> or for a vector <code>sort(v.begin(), v.end())</code>. For sorting in a self-defined order, one must use a custom comparator.
</p>
</div>
</div>
<div id="outline-container-orgb08378c" class="outline-3">
<h3 id="orgb08378c">Greedy Algorithms</h3>
<div class="outline-text-3" id="text-orgb08378c">
<p>Algorithms that select the most optimal choice at each step, instead of looking at the solution space as a whole. Usually in a greedy algorithm, there is a heuristic or value function that determines which choice is considered most optimal. The choice of the greedy algorithm matters too, for example in a scheduling problem choosing earliest starting next event would be incorrect, instead one should go for earliest ending next event because that would give one more choices for future events.
</p>

<p>Greedy won&rsquo;t work in all scenarios though, for example in the fairly popular coin change problem, if the denominations are <code>{1,3,4}</code> then greedy solution would be <code>{4,1,1}</code> but the correct least amount of coins would be two <code>{3,3}</code>. Similarly it cannot work for the knapsack problem which is solved using Dynamic Programming.
</p>
</div>
</div>
</div>
<div id="outline-container-orgdd63b05" class="outline-2">
<h2 id="orgdd63b05">Graph Theory</h2>
<div class="outline-text-2" id="text-orgdd63b05">
</div>
<div id="outline-container-orga709b54" class="outline-3">
<h3 id="orga709b54">Representation</h3>
<div class="outline-text-3" id="text-orga709b54">
<p>Graphs (N vertices and M edges) are usually given in the format: <code>N</code> <code>M</code> followed by the <code>M edges</code> each showing the connecting vertices. One thing to note is that a graph should be stored globally and statically, for access outside the main method. A graph can be represented in three ways:
</p>
</div>
<div id="outline-container-orgef38677" class="outline-4">
<h4 id="orgef38677">Adjacency List</h4>
<div class="outline-text-4" id="text-orgef38677">
<p>For using DFS, BFS, Dijkstra or other <code>single-source</code> traversal algorithms, it&rsquo;s the preferred way of storing graphs. In it, an array of length N of lists is maintained.
<img src="/assets/usaco-adj.png" alt="usaco-adj.png">
They take up <code>O(M+N)</code> space but allow for easy traversal among the neighbors of a vertex. Often, there&rsquo;s a need to maintain a <code>visited</code> array.
</p>
<pre class="src src-c++"><code>  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
  <span class="font-lock-type-face">vector</span>&lt;<span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">adj</span>[MAXN];
  <span class="font-lock-type-face">bool</span> <span class="font-lock-variable-name-face">visited</span>[MAXN];

  <span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
    cin &gt;&gt; n &gt;&gt; m;
    <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; m; i++){
      <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>;
      cin &gt;&gt; a &gt;&gt; b;
      a--; b--; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">subtract 1 for vertex since array is zero-indexed
</span>      adj[a].push_back(b);
      adj[b].push_back(a); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">omit for directed graph
</span>    }
  }

  <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">For a weighted graph:
</span>  <span class="font-lock-keyword-face">struct</span> <span class="font-lock-type-face">Edge</span>
  {
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">to</span>, <span class="font-lock-variable-name-face">weight</span>;
    <span class="font-lock-function-name-face">Edge</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">dest</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">w</span>):
    to(dest), weight(w)
    {
    }
  }</code></pre>
</div>
</div>
<div id="outline-container-orgc13d117" class="outline-4">
<h4 id="orgc13d117">Adjacency Matrix</h4>
<div class="outline-text-4" id="text-orgc13d117">
<p>This is an <code>N x N</code> 2D array that stores for each pair of indices(a,b) whether an edge exists between them or not. Primarily used for Floyd-Warshall Algorithm.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">adj</span>[MAXN][MAXN];

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
  cin &gt;&gt; n &gt;&gt; m;
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; m; i++){
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>;
    cin &gt;&gt; a &gt;&gt; b;
    a--; b--;
    adj[a][b] = 1; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">or w for weighted graph
</span>    adj[b][a] = 1; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">ignore this if directed
</span>  }
}</code></pre>
</div>
</div>
<div id="outline-container-org8772cb4" class="outline-4">
<h4 id="org8772cb4">Edge List</h4>
<div class="outline-text-4" id="text-org8772cb4">
<p>Usually used for weighted undirected graphs when sorting the edges by weight is needed (DSU). Its simply a single list of all edges <code>(a, b, w)</code> where a and b are the vertices and w is the weight of connecting edge. Each edge is added only oncce.
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">struct</span> <span class="font-lock-type-face">Edge</span>{
  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>, <span class="font-lock-variable-name-face">w</span>;
  <span class="font-lock-function-name-face">Edge</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">start</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">end</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">weight</span>):
  a(start), b(end), w(weight)
  {
  }
  <span class="font-lock-type-face">bool</span> <span class="font-lock-keyword-face">operator</span><span class="font-lock-function-name-face">&lt;</span>(<span class="font-lock-keyword-face">const</span> <span class="font-lock-type-face">Edge</span> &amp; <span class="font-lock-variable-name-face">e</span>)
  <span class="font-lock-keyword-face">const</span>{
    <span class="font-lock-keyword-face">return</span> w &lt; e.w; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">ascending weight sort
</span>  }
};

<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
<span class="font-lock-type-face">vector</span>&lt;<span class="font-lock-type-face">Edge</span>&gt; <span class="font-lock-variable-name-face">edges</span>;

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
  cin &gt;&gt; n &gt;&gt; m;
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; m; i++){
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>, <span class="font-lock-variable-name-face">w</span>;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
    a--; b--;
    edges.push_back(Edge(a, b, w)); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">add edge to list
</span>  }
  sort(edges.begin(), edges.end());
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-org0aba1dd" class="outline-3">
<h3 id="org0aba1dd">Traversal</h3>
<div class="outline-text-3" id="text-org0aba1dd">
</div>
<div id="outline-container-org4ae0e26" class="outline-4">
<h4 id="org4ae0e26">Breadth-First Search (BFS)</h4>
<div class="outline-text-4" id="text-org4ae0e26">
<p>Visits nodes in order of distance away from the starting node; first visit nodes that are one edge away then those that are two edges away and so on. It can be used for finding the distance from a starting node to all nodes in an unweighted graph.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">bfs</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">start</span>){
  <span class="font-lock-keyword-face">const</span> <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">total_nodes</span> = n;
  memset(dist, -1, <span class="font-lock-keyword-face">sizeof</span> dist); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">fill distance array with -1s
</span>  <span class="font-lock-type-face">queue</span>&lt;<span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">q</span>;
  dist[start] = 0;
  q.push(start);
  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">seen</span> = 1;
  <span class="font-lock-keyword-face">while</span>(<span class="font-lock-negation-char-face">!</span>q.empty()){
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">v</span> = q.front();
    q.pop();
    <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">e</span>: adj[v]){
      <span class="font-lock-keyword-face">if</span>(dist[e] == -1){
        dist[e] = dist[v] + 1;
        <span class="font-lock-keyword-face">if</span>(++seen == total_nodes) <span class="font-lock-keyword-face">break</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">see: https://observablehq.com/@yurivish/efficient-graph-search
</span>        q.push(e);
      }
    }
  }
}</code></pre>
<p>Once BFS finishes, the array <code>dist</code> contains the distances from the start node to each node.
</p>
</div>
</div>
<div id="outline-container-org477000d" class="outline-4">
<h4 id="org477000d">Depth-First Search (DFS)</h4>
<div class="outline-text-4" id="text-org477000d">
<p>Continues down a single path as far as possible until it has no more vertices to visit along that path, then backtracks and finds more vertices to visit.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">dfs</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">node</span>){
  visited[node] = <span class="font-lock-constant-face">true</span>;
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">next</span> : adj[node]){
    <span class="font-lock-keyword-face">if</span>(<span class="font-lock-negation-char-face">!</span>visited[next]){
      dfs(next);
    }
  }
}</code></pre>
<p>If stack overflows are encountered with recursive DFS, it can be implemented iteravely by storing nodes in the BFS implementation on a stack instead of a queue.
</p>
</div>
</div>
</div>
<div id="outline-container-org65b6eca" class="outline-3">
<h3 id="org65b6eca">Floodfill</h3>
<div class="outline-text-3" id="text-org65b6eca">
<p>Its DFS but on a grid and the aim is to find the connected component of all the connected cells with the same number. As opposed to an explicit graph where the edges are given, a grid is an implicit graph where the neighbours are nodes adjacent in the four directions.
</p>

<p>When doing floodfill, an <code>N x M</code> array of bools <code>visited</code> is maintained and a global variable for the size of currently visiting component. The search function is called recursively from squares on all four sides of the current one.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">grid</span>[MAXN][MAXM];
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
<span class="font-lock-type-face">bool</span> <span class="font-lock-variable-name-face">visited</span>[MAXN][MAXM];
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">currentCompSize</span> = 0;

<span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">floodfill</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">r</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">c</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">color</span>){
  <span class="font-lock-keyword-face">if</span>(r &lt; 0 || r &gt;= n || c &lt; 0 || c &gt;= m) <span class="font-lock-keyword-face">return</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">outside grid
</span>  <span class="font-lock-keyword-face">if</span>(grid[r][c] != color) <span class="font-lock-keyword-face">return</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">wrong color
</span>  <span class="font-lock-keyword-face">if</span>(visited[r][c]) <span class="font-lock-keyword-face">return</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">already visited
</span>
  visited[r][c] = <span class="font-lock-constant-face">true</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">mark current sq as visited
</span>  currentCompSize++;
  <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">recursively call floodfill for neighbour sqs
</span>  floodfill(r, c+1, color);
  floodfill(r, c-1, color);
  floodfill(r-1, c, color);
  floodfill(r+1, c, color);
}

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
  <span class="font-lock-comment-delimiter-face">/*</span><span class="font-lock-comment-face">
   * additional stuff here
</span><span class="font-lock-comment-delimiter-face">  */</span>
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; n; i++){
    <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">j</span> = 0; j &lt; m; j++){
      <span class="font-lock-keyword-face">if</span>(<span class="font-lock-negation-char-face">!</span>visited[i][j]){
        currentCompSize = 0;
        floodfill(i, j, grid[i][j]);
      }
    }
  }
}</code></pre>
</div>
</div>
<div id="outline-container-org274a54c" class="outline-3">
<h3 id="org274a54c">Disjoint-Set Union Data Structure</h3>
<div class="outline-text-3" id="text-org274a54c">
<p>It supports two operations:
</p>
<ul class="org-ul">
<li>Add an edge between two nodes</li>
<li>Check if two nodes are connected</li>
</ul>
<p>For this, the sets are stored as trees; initially each node is its own set then the sets are combined when an edge is added between two nodes.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">parent</span>[MAXN]; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">store root of each set
</span>
<span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">initialize</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">N</span>){
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; N; i++)
    parent[i] = i; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">initially, root of each set is node itself
</span>}

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">find</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">x</span>){ <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">find root of set of x
</span>  <span class="font-lock-keyword-face">if</span>(x == parent[x])
    <span class="font-lock-keyword-face">return</span> x; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">if x is its parent, it is the root
</span>  <span class="font-lock-keyword-face">else</span>
    <span class="font-lock-keyword-face">return</span> find(parent[x]);
}

<span class="font-lock-type-face">void</span> <span class="font-lock-keyword-face">union</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">b</span>){ <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">merge sets of a and b
</span>  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">c</span> = find(a);        <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">find a's root
</span>  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">d</span> = find(b);        <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">find b's root
</span>  <span class="font-lock-keyword-face">if</span> (c != d)
    parent[d] = c;        <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">merge sets by setting parent of d to c
</span>}</code></pre>
<p>The naive recursive implementation of find can be improved from <code>O(nm)</code> by path compression; the idea being reassignment of nodes on recursive calls to <code>find</code> to prevent formation of long chains and the runtime becomes <code>O(n log n)</code>.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">find</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">x</span>){
  <span class="font-lock-keyword-face">if</span>(x == parent[x])
    <span class="font-lock-keyword-face">return</span> x;
  <span class="font-lock-keyword-face">else</span>
    <span class="font-lock-keyword-face">return</span> parent[x] = find(parent[x]);
}</code></pre>
</div>
</div>
<div id="outline-container-org7f125bd" class="outline-3">
<h3 id="org7f125bd">Miscellaneous</h3>
<div class="outline-text-3" id="text-org7f125bd">
<ul class="org-ul">
<li>DAGs (Directed Acyclic graphs) by virtue of not having any cycles allows them to have an ordering of nodes such that for any edge from <i>u</i> to <i>v</i>, <i>u</i> appears before <i>v</i> (topological sorting).</li>
<li>Bipartite graph is such that each node can only be colored by 2 colors such that no adjacent nodes share the same colour. A graph is bipartite iff there are no cycles of odd length. A modified BFS can be use to check whether a graph is bipartite or not.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org16e2e0d" class="outline-2">
<h2 id="org16e2e0d">More Techniques</h2>
<div class="outline-text-2" id="text-org16e2e0d">
</div>
<div id="outline-container-org24a4e84" class="outline-3">
<h3 id="org24a4e84">Prefix Sums</h3>
<div class="outline-text-3" id="text-org24a4e84">
<p>To process queries to find the sum of elements between two indices in a list, prefix sum is useful. Using 1-index in the array is beneficial i.e. assigning <code>arr[0] = 0</code> and hence <code>prefix[0] = 0</code>.
</p>

<p>\(prefix[k] = \sum_{i=1}^{k}arr[i] = prefix[k-1] + arr[k]\)
</p>

<p>For processing Q queries consisting on an array of N elements, the complexity is <code>O(N+Q)</code>.
</p>

<div class="note" id="org44ddcf1">
<p>TODO: DP, 2D prefix sum as 1-D only
</p>

</div>
</div>
</div>
<div id="outline-container-orga76fd9b" class="outline-3">
<h3 id="orga76fd9b">Binary Search</h3>
</div>
<div id="outline-container-orge33bb7f" class="outline-3">
<h3 id="orge33bb7f">Basic Number Theory</h3>
<div class="outline-text-3" id="text-orge33bb7f">
<p>Prime factorization of a number is computed by this algorithm in \(O(\sqrt{n})\):
<img src="/assets/usaco-pf.png" alt="usaco-pf.png">
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">i</th>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">v</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-right">252</td>
<td class="org-left">{}</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">126</td>
<td class="org-left">{2}</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">63</td>
<td class="org-left">{2,2}</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">21</td>
<td class="org-left">{2,2,3}</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
<td class="org-left">{2,2,3,3}</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">1</td>
<td class="org-left">{2,2,3,3,7}</td>
</tr>
</tbody>
</table>
<p>GCD using Euclidean Algorithm in <code>O(log min(a,b))</code>:
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">gcd</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">b</span>){
  <span class="font-lock-keyword-face">if</span>(<span class="font-lock-negation-char-face">!</span>b) <span class="font-lock-keyword-face">return</span> a;
  <span class="font-lock-keyword-face">return</span> gcd(b, a%b);
}</code></pre>
<p>LCM can be computed using GCD by \(\frac{a \times b}{gcd(a,b)}\)
</p>

<p>Modular Arithmetic is useful for dealing with overflows by taking remainders:
</p>

<p>\[\begin{align*}
(a \pm b)\mod m &= (a\mod m \pm b\mod m)\mod m \\
(a \times b)\mod m &= ((a\mod m) \times (b\mod m))\mod m \\
a^{b}\mod m &= (a\mod m)^{b}\mod m
\end{align*}\]
</p>
</div>
</div>
</div>
<div id="outline-container-orgeee903e" class="outline-2">
<h2 id="orgeee903e">Additional Topics</h2>
<div class="outline-text-2" id="text-orgeee903e">
<ul class="org-ul">
<li>Two Pointers <br>
Iterate across an array that track the start and end of an interval or values in a sorted array. Both pointers are monotonic i.e. start at one end of array and move in only one direction.</li>
</ul>
</div>
<div id="outline-container-org2d41fbd" class="outline-3">
<h3 id="org2d41fbd">Line Sweep</h3>
</div>
<div id="outline-container-orgb8ceff3" class="outline-3">
<h3 id="orgb8ceff3">Bitwise Operations</h3>
</div>
<div id="outline-container-orgb597c13" class="outline-3">
<h3 id="orgb597c13">Ad-hoc</h3>
</div>
</div>
</div>
<footer id="postamble" class="status">
&copy; 2026 . Made with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 31.0.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11).
</footer>
</body>
</html>
