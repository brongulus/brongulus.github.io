<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2026 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IUSACO</title>
<meta name="author" content="Tak" />
<meta name="generator" content="Org Mode" />
<script src='/css/head.js'></script> <link rel='stylesheet' type='text/css' href='/css/stylesheet.css'>

<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css' integrity='sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC' crossorigin='anonymous'>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js' integrity='sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja' crossorigin='anonymous'></script>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js' integrity='sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR' crossorigin='anonymous'></script>
<script defer>
document.addEventListener('DOMContentLoaded', function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
    });
});
</script>
</head>
<body>
<div id="nav" class="status">
<a href='/'>bacchanalian madness</a> / <a href='/rss'>rss</a> / <label id='dark-mode-button'> <input type='checkbox'> </label>
</div>
<div id="content" class="content">
<header>
<h1 class="title">IUSACO</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2fe8fa4">Input and Output</a></li>
<li><a href="#orgd094a5d">Complexity and algorithm analysis</a></li>
<li><a href="#org3351bcb">Built-in Data Structures</a></li>
<li><a href="#org93723e9">Elementary Techniques</a></li>
<li><a href="#orgf949936">Graph Theory</a></li>
<li><a href="#orgf569f06">More Techniques</a></li>
<li><a href="#org73aa983">Additional Topics</a></li>
</ul>
</div>
</nav>
<p>CLOSED: <span class="timestamp-wrapper"><span class="timestamp">[2022-06-05 Sun]</span></span>
</p>
<div id="outline-container-org2fe8fa4" class="outline-2">
<h2 id="org2fe8fa4">Input and Output</h2>
<div class="outline-text-2" id="text-org2fe8fa4">
<pre class="src src-c++"><code><span class="font-lock-preprocessor-face">  #include</span> <span class="font-lock-string-face">&lt;cstdio&gt;</span>
  <span class="font-lock-keyword-face">using</span> <span class="font-lock-keyword-face">namespace</span> <span class="font-lock-constant-face">std</span>;
  <span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>() {
      freopen(<span class="font-lock-string-face">"template.in"</span>, <span class="font-lock-string-face">"r"</span>, stdin);
      freopen(<span class="font-lock-string-face">"template.out"</span>, <span class="font-lock-string-face">"w"</span>, stdout);
  }</code></pre>
<ul class="org-ul">
<li>When using C++, arrays should be declared globally, or initialized to zeros if declared locally to avoid garbage values.</li>
<li>32bit int: \(\pm 2\times10^{9}\) v/s 64bit int: \(\pm 9\times 10^{18}\)</li>
</ul>
</div>
</div>
<div id="outline-container-orgd094a5d" class="outline-2">
<h2 id="orgd094a5d">Complexity and algorithm analysis</h2>
<div class="outline-text-2" id="text-orgd094a5d">
<ul class="org-ul">
<li>Elementary mathematical calculation: O(1)</li>
<li>Unordered set/map: O(1) per operation</li>
<li>Binary Search: O(log n)</li>
<li>Ordered set/map or Priority Queue: O(log n) per operation</li>
<li>Prime factorization or primality check for int: \(O(\sqrt{n})\)</li>
<li>Reading n inputs: O(n)</li>
<li>Iterating through n element array: O(n)</li>
<li>Sorting: Usually O(n log n) for <code>std::sort()</code></li>
<li>Iterating through all subsets of size k of input elements: O(\(n^{k}\) ), for triplets O(\(n^{3}\))</li>
<li>Iterating through all subsets: O(\(2^{n}\))</li>
<li>Iterating through all permutations: O(n!)</li>
</ul>
</div>
</div>
<div id="outline-container-org3351bcb" class="outline-2">
<h2 id="org3351bcb">Built-in Data Structures</h2>
<div class="outline-text-2" id="text-org3351bcb">
<p>Data Structure determines how data is stored, each supports some operations efficiently. In following discussion, desired data type is put between <code>&lt;&gt;</code>. Most std structures support <code>size()</code> and <code>empty()</code> methods.
</p>
</div>
<div id="outline-container-org337d446" class="outline-3">
<h3 id="org337d446">Iterators</h3>
<div class="outline-text-3" id="text-org337d446">
<p>Allows for traversal of a container with the help of a pointer.
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">for</span> (<span class="font-lock-constant-face">vector</span>&lt;<span class="font-lock-type-face">int</span>&gt;::<span class="font-lock-type-face">iterator</span> <span class="font-lock-variable-name-face">it</span> = myvector.begin(); it != myvector.end(); ++it) {
  cout &lt;&lt; *it; <span class="font-lock-comment-delimiter-face">//</span><span class="font-lock-comment-face">prints the values in the vector using the pointer
</span>}</code></pre>

<p>Alternate way to achieve the same with a for-each loop and <code>auto</code>.
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">for</span>(<span class="font-lock-keyword-face">auto</span> <span class="font-lock-variable-name-face">element</span> : v){
  cout &lt;&lt; element; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">prints values in vector
</span>}</code></pre>
</div>
</div>
<div id="outline-container-org2a145c5" class="outline-3">
<h3 id="org2a145c5">Dynamic Arrays</h3>
<div class="outline-text-3" id="text-org2a145c5">
<p>Addition and deletion at the end in O(1) time and in the middle in O(n) time.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">vector</span>&lt;<span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">v</span>;
<span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 1; i &lt;= 10; i++){
  v.push_back(i); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">stores 1 to 10 in a dynamic array
</span>}</code></pre>

<p>Vectors can be made static sized by initializing it with a size, <code>vector&lt;int&gt; v(30);</code>. They also support an <code>v.erase()</code> operation. A dynamic array can be sorted (default ascending) by <code>sort(v.begin(), v.end())</code>.
</p>
</div>
</div>
<div id="outline-container-orgcbedff0" class="outline-3">
<h3 id="orgcbedff0">Stacks and Queues</h3>
<div class="outline-text-3" id="text-orgcbedff0">
<p><b>Stacks</b>: LIFO with operations <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) all of which are O(1). Declared as <code>stack&lt;int&gt; s</code>.
</p>

<p><b>Queues</b>: FIFO with operations <code>push</code> (add in front), <code>pop</code> (remove at end) and <code>front</code> (show end) in O(1).
</p>

<p><b>Deques</b>: Combination of a stack and a queue supporting insertion and deletion from both front and end. Operations are aptly named as <code>push_back</code>, <code>push_font</code>, <code>pop_back</code> and <code>pop_front</code>.
</p>

<p><b>Priority Queues</b>: Supports insertion of elements and deletion and retrieval of element <i>with highest priority</i> in O(log n) where priority is based on a comparator function (highest element in front). Has <code>push</code> (add at end), <code>pop</code> (remove at end) and <code>top</code> (show end) operations and is declared as <code>priority_queue&lt;int&gt; pq;</code>.
</p>
</div>
</div>
<div id="outline-container-orgb66ccec" class="outline-3">
<h3 id="orgb66ccec">Sets</h3>
<div class="outline-text-3" id="text-orgb66ccec">
<p>A <i>set</i> is a collection of objects having no duplicates.
</p>

<p><b>Unordered Sets</b>: Work by hashing that is, assigning a unique code to every object allowing for <code>insert</code>, <code>erase</code> and <code>count</code> (set contains element then 1 else 0) in O(1). Traversal is pointless. Declared as <code>unordered_set&lt;int&gt; s</code>.
</p>

<pre class="src src-c++"><code><span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">element</span> : s){
  cout &lt;&lt; element &lt;&lt; <span class="font-lock-string-face">" "</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">iterating through a set, arbitrary order
</span>}</code></pre>

<p><b>Ordered Sets</b>: Insertion, deletion and search needs O(log n) time. Has additional operations <code>begin()</code> (iterator to lowest element), <code>end()</code>, <code>lower_bound()</code> (iterator to least element &ge; some k) and <code>upper_bound()</code>.
</p>

<p><b>Multisets</b>: A sorted set allowing multiple copies of same element, whose <code>count</code> operation returns the number of times an element is present in set. Time complexity of this operation is O(log n + f) where <i>log n</i> factor searches for element and <i>f</i> factor iterates through sorted set to get count. Declared as <code>multiset&lt;int&gt; ms</code>.
</p>
</div>
</div>
<div id="outline-container-org0c3ad4f" class="outline-3">
<h3 id="org0c3ad4f">Maps</h3>
<div class="outline-text-3" id="text-org0c3ad4f">
<p>A <i>map</i> is a set of <i>ordered pairs</i> called key and value where keys must be unique but values can be repeated. Supported operations are addition and removal of key-value pair and <i>retrieval</i> of values for a given key. Unordered maps perform aforementioned methods in O(1) whereas for ordered maps it's O(log n), sorted in order of key.
</p>

<p><b>Unordered Maps</b>: In map <code>m</code>, <code>m[key] = value</code> operator assigns value to a key and places the pair on the map, <code>m[key]</code> returns value associated with the key, <code>count(key)</code> checks for existence of key in the map and <code>erase(it)</code> removes pair associated with a key or iterator. Declared as <code>unordered_map&lt;int, int&gt; m</code>.
</p>

<p><b>Ordered Maps</b>: Supports additional operations <code>lower_bound</code> and <code>upper_bound</code> which return iterators pointing to lowest entry not less than/ strictly greater than a specified key.
</p>

<pre class="src src-c++"><code><span class="font-lock-type-face">map</span>&lt;<span class="font-lock-type-face">int</span>, <span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">m</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">[(3,5); (11,4)]
</span>m[10] = 491; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">[(3,5); (10,491); (11,4)]
</span>cout &lt;&lt; m.lower_bound(10)-&gt;first &lt;&lt; <span class="font-lock-string-face">" "</span> &lt;&lt; m.lower_bound(10)-&gt;second &lt;&lt; <span class="font-lock-string-face">"\n"</span>;
<span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">10 491
</span>cout &lt;&lt; m.upper_bound(10)-&gt;first &lt;&lt; <span class="font-lock-string-face">" "</span> &lt;&lt; m.upper_bound(10)-&gt;second &lt;&lt; <span class="font-lock-string-face">"\n"</span>;
<span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">11 4
</span>m.erase(11); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">[(3,5); (10,491)]</span></code></pre>
</div>
</div>
</div>
<div id="outline-container-org93723e9" class="outline-2">
<h2 id="org93723e9">Elementary Techniques</h2>
<div class="outline-text-2" id="text-org93723e9">
</div>
<div id="outline-container-org712379e" class="outline-3">
<h3 id="org712379e">Simulation</h3>
<div class="outline-text-3" id="text-org712379e">
<p>Simulation refers to the act of doing precisely what the problem statement states and nothing else; essentially simulating it.
</p>
</div>
</div>
<div id="outline-container-orgc87889f" class="outline-3">
<h3 id="orgc87889f">Complete Search</h3>
<div class="outline-text-3" id="text-orgc87889f">
<p>Brute forcing through all the possible cases in solution space to arrive at the solution. To iterate through all permutations of a list:
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">do</span> {
  check(v); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">process or check the current permutation for validity
</span>} <span class="font-lock-keyword-face">while</span>(next_permutation(v.begin(), v.end()));</code></pre>
</div>
</div>
<div id="outline-container-org6908a6d" class="outline-3">
<h3 id="org6908a6d">Sorting and Comparators</h3>
<div class="outline-text-3" id="text-org6908a6d">
<p>C++ has built-in function for sorting in ascending order: <code>std::sort(arr, arr+N)</code> or for a vector <code>sort(v.begin(), v.end())</code>. For sorting in a self-defined order, one must use a custom comparator.
</p>
</div>
</div>
<div id="outline-container-orgba8a1f8" class="outline-3">
<h3 id="orgba8a1f8">Greedy Algorithms</h3>
<div class="outline-text-3" id="text-orgba8a1f8">
<p>Algorithms that select the most optimal choice at each step, instead of looking at the solution space as a whole. Usually in a greedy algorithm, there is a heuristic or value function that determines which choice is considered most optimal. The choice of the greedy algorithm matters too, for example in a scheduling problem choosing earliest starting next event would be incorrect, instead one should go for earliest ending next event because that would give one more choices for future events.
</p>

<p>Greedy won't work in all scenarios though, for example in the fairly popular coin change problem, if the denominations are <code>{1,3,4}</code> then greedy solution would be <code>{4,1,1}</code> but the correct least amount of coins would be two <code>{3,3}</code>. Similarly it cannot work for the knapsack problem which is solved using Dynamic Programming.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf949936" class="outline-2">
<h2 id="orgf949936">Graph Theory</h2>
<div class="outline-text-2" id="text-orgf949936">
</div>
<div id="outline-container-org099889f" class="outline-3">
<h3 id="org099889f">Representation</h3>
<div class="outline-text-3" id="text-org099889f">
<p>Graphs (N vertices and M edges) are usually given in the format: <code>N</code> <code>M</code> followed by the <code>M edges</code> each showing the connecting vertices. One thing to note is that a graph should be stored globally and statically, for access outside the main method. A graph can be represented in three ways:
</p>
</div>
<div id="outline-container-orge70d326" class="outline-4">
<h4 id="orge70d326">Adjacency List</h4>
<div class="outline-text-4" id="text-orge70d326">
<p>For using DFS, BFS, Dijkstra or other <code>single-source</code> traversal algorithms, it's the preferred way of storing graphs. In it, an array of length N of lists is maintained.
<img src="/assets/usaco-adj.png" alt="usaco-adj.png">
They take up <code>O(M+N)</code> space but allow for easy traversal among the neighbors of a vertex. Often, there's a need to maintain a <code>visited</code> array.
</p>
<pre class="src src-c++"><code>  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
  <span class="font-lock-type-face">vector</span>&lt;<span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">adj</span>[MAXN];
  <span class="font-lock-type-face">bool</span> <span class="font-lock-variable-name-face">visited</span>[MAXN];

  <span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
    cin &gt;&gt; n &gt;&gt; m;
    <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; m; i++){
      <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>;
      cin &gt;&gt; a &gt;&gt; b;
      a--; b--; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">subtract 1 for vertex since array is zero-indexed
</span>      adj[a].push_back(b);
      adj[b].push_back(a); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">omit for directed graph
</span>    }
  }

  <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">For a weighted graph:
</span>  <span class="font-lock-keyword-face">struct</span> <span class="font-lock-type-face">Edge</span>
  {
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">to</span>, <span class="font-lock-variable-name-face">weight</span>;
    <span class="font-lock-function-name-face">Edge</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">dest</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">w</span>):
    to(dest), weight(w)
    {
    }
  }</code></pre>
</div>
</div>
<div id="outline-container-org9796ecd" class="outline-4">
<h4 id="org9796ecd">Adjacency Matrix</h4>
<div class="outline-text-4" id="text-org9796ecd">
<p>This is an <code>N x N</code> 2D array that stores for each pair of indices(a,b) whether an edge exists between them or not. Primarily used for Floyd-Warshall Algorithm.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">adj</span>[MAXN][MAXN];

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
  cin &gt;&gt; n &gt;&gt; m;
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; m; i++){
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>;
    cin &gt;&gt; a &gt;&gt; b;
    a--; b--;
    adj[a][b] = 1; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">or w for weighted graph
</span>    adj[b][a] = 1; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">ignore this if directed
</span>  }
}</code></pre>
</div>
</div>
<div id="outline-container-orga80a1a4" class="outline-4">
<h4 id="orga80a1a4">Edge List</h4>
<div class="outline-text-4" id="text-orga80a1a4">
<p>Usually used for weighted undirected graphs when sorting the edges by weight is needed (DSU). Its simply a single list of all edges <code>(a, b, w)</code> where a and b are the vertices and w is the weight of connecting edge. Each edge is added only oncce.
</p>
<pre class="src src-c++"><code><span class="font-lock-keyword-face">struct</span> <span class="font-lock-type-face">Edge</span>{
  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>, <span class="font-lock-variable-name-face">w</span>;
  <span class="font-lock-function-name-face">Edge</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">start</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">end</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">weight</span>):
  a(start), b(end), w(weight)
  {
  }
  <span class="font-lock-type-face">bool</span> <span class="font-lock-keyword-face">operator</span><span class="font-lock-function-name-face">&lt;</span>(<span class="font-lock-keyword-face">const</span> <span class="font-lock-type-face">Edge</span> &amp; <span class="font-lock-variable-name-face">e</span>)
  <span class="font-lock-keyword-face">const</span>{
    <span class="font-lock-keyword-face">return</span> w &lt; e.w; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">ascending weight sort
</span>  }
};

<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
<span class="font-lock-type-face">vector</span>&lt;<span class="font-lock-type-face">Edge</span>&gt; <span class="font-lock-variable-name-face">edges</span>;

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
  cin &gt;&gt; n &gt;&gt; m;
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; m; i++){
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-variable-name-face">b</span>, <span class="font-lock-variable-name-face">w</span>;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
    a--; b--;
    edges.push_back(Edge(a, b, w)); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">add edge to list
</span>  }
  sort(edges.begin(), edges.end());
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-org2be5874" class="outline-3">
<h3 id="org2be5874">Traversal</h3>
<div class="outline-text-3" id="text-org2be5874">
</div>
<div id="outline-container-orgc661b8c" class="outline-4">
<h4 id="orgc661b8c">Breadth-First Search (BFS)</h4>
<div class="outline-text-4" id="text-orgc661b8c">
<p>Visits nodes in order of distance away from the starting node; first visit nodes that are one edge away then those that are two edges away and so on. It can be used for finding the distance from a starting node to all nodes in an unweighted graph.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">bfs</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">start</span>){
  <span class="font-lock-keyword-face">const</span> <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">total_nodes</span> = n;
  memset(dist, -1, <span class="font-lock-keyword-face">sizeof</span> dist); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">fill distance array with -1s
</span>  <span class="font-lock-type-face">queue</span>&lt;<span class="font-lock-type-face">int</span>&gt; <span class="font-lock-variable-name-face">q</span>;
  dist[start] = 0;
  q.push(start);
  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">seen</span> = 1;
  <span class="font-lock-keyword-face">while</span>(<span class="font-lock-negation-char-face">!</span>q.empty()){
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">v</span> = q.front();
    q.pop();
    <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">e</span>: adj[v]){
      <span class="font-lock-keyword-face">if</span>(dist[e] == -1){
        dist[e] = dist[v] + 1;
        <span class="font-lock-keyword-face">if</span>(++seen == total_nodes) <span class="font-lock-keyword-face">break</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">see: https://observablehq.com/@yurivish/efficient-graph-search
</span>        q.push(e);
      }
    }
  }
}</code></pre>
<p>Once BFS finishes, the array <code>dist</code> contains the distances from the start node to each node.
</p>
</div>
</div>
<div id="outline-container-orgf342ab2" class="outline-4">
<h4 id="orgf342ab2">Depth-First Search (DFS)</h4>
<div class="outline-text-4" id="text-orgf342ab2">
<p>Continues down a single path as far as possible until it has no more vertices to visit along that path, then backtracks and finds more vertices to visit.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">dfs</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">node</span>){
  visited[node] = <span class="font-lock-constant-face">true</span>;
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">next</span> : adj[node]){
    <span class="font-lock-keyword-face">if</span>(<span class="font-lock-negation-char-face">!</span>visited[next]){
      dfs(next);
    }
  }
}</code></pre>
<p>If stack overflows are encountered with recursive DFS, it can be implemented iteravely by storing nodes in the BFS implementation on a stack instead of a queue.
</p>
</div>
</div>
</div>
<div id="outline-container-org760cd5e" class="outline-3">
<h3 id="org760cd5e">Floodfill</h3>
<div class="outline-text-3" id="text-org760cd5e">
<p>Its DFS but on a grid and the aim is to find the connected component of all the connected cells with the same number. As opposed to an explicit graph where the edges are given, a grid is an implicit graph where the neighbours are nodes adjacent in the four directions.
</p>

<p>When doing floodfill, an <code>N x M</code> array of bools <code>visited</code> is maintained and a global variable for the size of currently visiting component. The search function is called recursively from squares on all four sides of the current one.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">grid</span>[MAXN][MAXM];
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">n</span>, <span class="font-lock-variable-name-face">m</span>;
<span class="font-lock-type-face">bool</span> <span class="font-lock-variable-name-face">visited</span>[MAXN][MAXM];
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">currentCompSize</span> = 0;

<span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">floodfill</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">r</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">c</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">color</span>){
  <span class="font-lock-keyword-face">if</span>(r &lt; 0 || r &gt;= n || c &lt; 0 || c &gt;= m) <span class="font-lock-keyword-face">return</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">outside grid
</span>  <span class="font-lock-keyword-face">if</span>(grid[r][c] != color) <span class="font-lock-keyword-face">return</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">wrong color
</span>  <span class="font-lock-keyword-face">if</span>(visited[r][c]) <span class="font-lock-keyword-face">return</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">already visited
</span>
  visited[r][c] = <span class="font-lock-constant-face">true</span>; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">mark current sq as visited
</span>  currentCompSize++;
  <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">recursively call floodfill for neighbour sqs
</span>  floodfill(r, c+1, color);
  floodfill(r, c-1, color);
  floodfill(r-1, c, color);
  floodfill(r+1, c, color);
}

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(){
  <span class="font-lock-comment-delimiter-face">/*</span><span class="font-lock-comment-face">
   * additional stuff here
</span><span class="font-lock-comment-delimiter-face">  */</span>
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; n; i++){
    <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">j</span> = 0; j &lt; m; j++){
      <span class="font-lock-keyword-face">if</span>(<span class="font-lock-negation-char-face">!</span>visited[i][j]){
        currentCompSize = 0;
        floodfill(i, j, grid[i][j]);
      }
    }
  }
}</code></pre>
</div>
</div>
<div id="outline-container-orge826934" class="outline-3">
<h3 id="orge826934">Disjoint-Set Union Data Structure</h3>
<div class="outline-text-3" id="text-orge826934">
<p>It supports two operations:
</p>
<ul class="org-ul">
<li>Add an edge between two nodes</li>
<li>Check if two nodes are connected</li>
</ul>
<p>For this, the sets are stored as trees; initially each node is its own set then the sets are combined when an edge is added between two nodes.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">parent</span>[MAXN]; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">store root of each set
</span>
<span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">initialize</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">N</span>){
  <span class="font-lock-keyword-face">for</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; N; i++)
    parent[i] = i; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">initially, root of each set is node itself
</span>}

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">find</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">x</span>){ <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">find root of set of x
</span>  <span class="font-lock-keyword-face">if</span>(x == parent[x])
    <span class="font-lock-keyword-face">return</span> x; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">if x is its parent, it is the root
</span>  <span class="font-lock-keyword-face">else</span>
    <span class="font-lock-keyword-face">return</span> find(parent[x]);
}

<span class="font-lock-type-face">void</span> <span class="font-lock-keyword-face">union</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">b</span>){ <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">merge sets of a and b
</span>  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">c</span> = find(a);        <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">find a's root
</span>  <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">d</span> = find(b);        <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">find b's root
</span>  <span class="font-lock-keyword-face">if</span> (c != d)
    parent[d] = c;        <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">merge sets by setting parent of d to c
</span>}</code></pre>
<p>The naive recursive implementation of find can be improved from <code>O(nm)</code> by path compression; the idea being reassignment of nodes on recursive calls to <code>find</code> to prevent formation of long chains and the runtime becomes <code>O(n log n)</code>.
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">find</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">x</span>){
  <span class="font-lock-keyword-face">if</span>(x == parent[x])
    <span class="font-lock-keyword-face">return</span> x;
  <span class="font-lock-keyword-face">else</span>
    <span class="font-lock-keyword-face">return</span> parent[x] = find(parent[x]);
}</code></pre>
</div>
</div>
<div id="outline-container-org7be507c" class="outline-3">
<h3 id="org7be507c">Miscellaneous</h3>
<div class="outline-text-3" id="text-org7be507c">
<ul class="org-ul">
<li>DAGs (Directed Acyclic graphs) by virtue of not having any cycles allows them to have an ordering of nodes such that for any edge from <i>u</i> to <i>v</i>, <i>u</i> appears before <i>v</i> (topological sorting).</li>
<li>Bipartite graph is such that each node can only be colored by 2 colors such that no adjacent nodes share the same colour. A graph is bipartite iff there are no cycles of odd length. A modified BFS can be use to check whether a graph is bipartite or not.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf569f06" class="outline-2">
<h2 id="orgf569f06">More Techniques</h2>
<div class="outline-text-2" id="text-orgf569f06">
</div>
<div id="outline-container-orgb549809" class="outline-3">
<h3 id="orgb549809">Prefix Sums</h3>
<div class="outline-text-3" id="text-orgb549809">
<p>To process queries to find the sum of elements between two indices in a list, prefix sum is useful. Using 1-index in the array is beneficial i.e. assigning <code>arr[0] = 0</code> and hence <code>prefix[0] = 0</code>.
</p>

<p>\(prefix[k] = \sum_{i=1}^{k}arr[i] = prefix[k-1] + arr[k]\)
</p>

<p>For processing Q queries consisting on an array of N elements, the complexity is <code>O(N+Q)</code>.
</p>

<div class="note" id="org8e874d2">
<p>TODO: DP, 2D prefix sum as 1-D only
</p>

</div>
</div>
</div>
<div id="outline-container-org8367fa1" class="outline-3">
<h3 id="org8367fa1">Binary Search</h3>
</div>
<div id="outline-container-orgbf40b04" class="outline-3">
<h3 id="orgbf40b04">Basic Number Theory</h3>
<div class="outline-text-3" id="text-orgbf40b04">
<p>Prime factorization of a number is computed by this algorithm in \(O(\sqrt{n})\):
<img src="/assets/usaco-pf.png" alt="usaco-pf.png">
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">i</th>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">v</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-right">252</td>
<td class="org-left">{}</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">126</td>
<td class="org-left">{2}</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">63</td>
<td class="org-left">{2,2}</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">21</td>
<td class="org-left">{2,2,3}</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
<td class="org-left">{2,2,3,3}</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">1</td>
<td class="org-left">{2,2,3,3,7}</td>
</tr>
</tbody>
</table>
<p>GCD using Euclidean Algorithm in <code>O(log min(a,b))</code>:
</p>
<pre class="src src-c++"><code><span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">gcd</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">a</span>, <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">b</span>){
  <span class="font-lock-keyword-face">if</span>(<span class="font-lock-negation-char-face">!</span>b) <span class="font-lock-keyword-face">return</span> a;
  <span class="font-lock-keyword-face">return</span> gcd(b, a%b);
}</code></pre>
<p>LCM can be computed using GCD by \(\frac{a \times b}{gcd(a,b)}\)
</p>

<p>Modular Arithmetic is useful for dealing with overflows by taking remainders:
</p>

<p>\[\begin{align*}
(a \pm b)\mod m &= (a\mod m \pm b\mod m)\mod m \\
(a \times b)\mod m &= ((a\mod m) \times (b\mod m))\mod m \\
a^{b}\mod m &= (a\mod m)^{b}\mod m
\end{align*}\]
</p>
</div>
</div>
</div>
<div id="outline-container-org73aa983" class="outline-2">
<h2 id="org73aa983">Additional Topics</h2>
<div class="outline-text-2" id="text-org73aa983">
<ul class="org-ul">
<li>Two Pointers <br>
Iterate across an array that track the start and end of an interval or values in a sorted array. Both pointers are monotonic i.e. start at one end of array and move in only one direction.</li>
</ul>
</div>
<div id="outline-container-org07a4810" class="outline-3">
<h3 id="org07a4810">Line Sweep</h3>
</div>
<div id="outline-container-orgd616d69" class="outline-3">
<h3 id="orgd616d69">Bitwise Operations</h3>
</div>
<div id="outline-container-org30bb606" class="outline-3">
<h3 id="org30bb606">Ad-hoc</h3>
</div>
</div>
</div>
<footer id="postamble" class="status">
&copy; 2026 . Made with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 31.0.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11).
</footer>
</body>
</html>
