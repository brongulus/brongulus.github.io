<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@1,6..96,500&family=Cormorant:ital,wght@0,400;1,300&family=Josefin+Sans:wght@200;300&family=Roboto+Mono:wght@300&family=Inter:wght@600&family=Source+Sans+Pro:wght@300;400&family=Source+Serif+Pro:ital,wght@0,300;0,400;1,300;1,400&family=Open+Sans&family=Playfair+Display&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/victormono@latest/dist/index.min.css">
    
    <script> 
      function setTheme() {
          if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
              document.documentElement.setAttribute("data-theme", "dark");
              return;
          }
          else {
              document.documentElement.setAttribute("data-theme", "light");
              return;
          }
      }
    </script>
    <script>
      if (localStorage.theme) document.documentElement.setAttribute("data-theme", localStorage.theme); 
    </script>
  </head>
  <body>
    <div class="content">
      
        <div class = "container">
          <head>
  
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>2 Fast 2 MCM &middot; bacchanalian madness</title>
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="manifest" href=" /images/site.webmanifest">
  
  <link href="" rel="alternate" type="application/rss+xml" title="bacchanalian madness" />
</head>

          		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<div class="title" style="white-space: nowrap;">
						<h1 class="nav-title"><b>bacchanalian madness</b></h1>
					</div>
				</a>

				<aside>
    <ul>
        
        
            
                <li>
                    <a href="/blog/">
                        
                        <span>Blog</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/meta/">
                        
                        <span>Meta</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/notes/">
                        
                        <span>Notes</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/tags/">
                        
                        <span>Tags</span>
                    </a>
                </li>
            
        
        <li>
            <a href="/index.xml">RSS</a> 
        </li>
        <li>
            <div id="dark-mode-button">
                <input type="checkbox" class="toggle" id="check"/>
                <label for="check" class="themebox">
                </label>
            </div>
        </li>
    </ul>
</aside>


			</div>
		</nav>

          

<main>
	<div class="post">
		<div class="post-info">
    
    
    
    
        
        
        <time datetime="2025-01-15 00:07:00 &#43;0530 IST">January 15, 2025</time>
</div>

		<h1 class="post-title">2 Fast 2 MCM</h1>

		

		

		
			<nav id="TableOfContents">
  <ul>
    <li><a href="#machine-controller-manager-architecture">Machine Controller Manager Architecture</a></li>
    <li><a href="#machine-controller-core-flows">Machine Controller Core Flows</a></li>
    <li><a href="#safety-controller">Safety Controller</a></li>
    <li><a href="#machineset-controller">MachineSet Controller</a></li>
    <li><a href="#machinedeployment-controller">MachineDeployment Controller</a></li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
		

		<p>These visual representations helps understand the complex workflows within the Machine Controller Manager.</p>
<h2 id="machine-controller-manager-architecture">Machine Controller Manager Architecture</h2>
<ul>
<li>The system consists of three main controllers working in concert</li>
<li>Each controller handles specific aspects of machine lifecycle management</li>
<li>Interfaces with both cloud providers and Kubernetes clusters</li>
<li>Manages the full lifecycle of machines from creation to deletion</li>
</ul>
<p>Let&rsquo;s start with an overview of the main components and their interactions:</p>
<pre class="mermaid">stateDiagram-v2
    direction TB
    
    state &#34;Machine Controller Manager&#34; as MCM {
        state &#34;Machine Controller&#34; as MC
        state &#34;Safety Controller&#34; as SC
        state &#34;MCM Controller&#34; as MCMC
        
        [*] --&gt; MC
        [*] --&gt; SC
        [*] --&gt; MCMC
    }
    
    state &#34;Cloud Provider&#34; as CP {
        VMs
        API
    }
    
    state &#34;Kubernetes Cluster&#34; as K8S {
        state &#34;Control Plane&#34; as CP_K8S {
            API_Server
            etcd
        }
        
        state &#34;Node Components&#34; as NC {
            kubelet
            container_runtime
        }
    }
    
    MCM --&gt; CP : Manages VMs
    MCM --&gt; K8S : Manages Nodes
    
    note right of MCM
        Handles:
        - Machine lifecycle
        - Safety checks
        - Deployments/Sets
    end note
</pre>

<h2 id="machine-controller-core-flows">Machine Controller Core Flows</h2>
<p>Now, let&rsquo;s dive into the Machine Controller&rsquo;s core reconciliation flows for different resources. It handles three main types of reconciliation:</p>
<ul>
<li>Secret Reconciliation: Manages secrets referenced by MachineClasses</li>
<li>MachineClass Reconciliation: Handles machine class lifecycle</li>
<li>Machine Reconciliation: Core machine lifecycle management</li>
</ul>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;Machine Controller&#34; as MC {
        state &#34;Secret Reconciliation&#34; as SR {
            [*] --&gt; FetchSecret
            FetchSecret --&gt; GetMachineClass
            GetMachineClass --&gt; CheckReferences
            CheckReferences --&gt; FinalizerAdd : Has References
            CheckReferences --&gt; FinalizerRemove : No References
            FinalizerAdd --&gt; [*]
            FinalizerRemove --&gt; [*]
        }

        state &#34;MachineClass Reconciliation&#34; as MCR {
            [*] --&gt; FetchClass
            FetchClass --&gt; GetMachines
            GetMachines --&gt; CheckMachines
            CheckMachines --&gt; AddFinalizer : Has Machines
            CheckMachines --&gt; RemoveFinalizer : No Machines
            AddFinalizer --&gt; EnqueueMachines
            EnqueueMachines --&gt; [*]
            RemoveFinalizer --&gt; [*]
        }

        state &#34;Machine Reconciliation&#34; as MR {
            [*] --&gt; FetchMachine
            FetchMachine --&gt; CheckFrozen
            
            CheckFrozen --&gt; ValidateMachine : Not Frozen
            CheckFrozen --&gt; RetryLater : Frozen
            
            ValidateMachine --&gt; ValidateMachineClass
            VaildateMachineClass --&gt; DeletionTimestamp

            DeletionTimestamp --&gt; DeletionFlow : Deletion Requested
            DeletionTimestamp --&gt; AddFinalizers : No Deletion
            
            AddFinalizers --&gt; CheckPhase&amp;NodeLabel
            
            CheckPhase&amp;NodeLabel --&gt; ReconcileHealth : Has Node &amp; Non-empty phase
            CheckPhase&amp;NodeLabel --&gt; CreationFlow : No Node or&lt;br/&gt;CrashLoopBackOff&lt;br/&gt;or EmptyPhase
            
            ReconcileHealth --&gt; SyncNodeName
            SyncNodeName --&gt; SyncTemplates
            SyncTemplates --&gt; [*]
            
            CreationFlow --&gt; [*]
            DeletionFlow --&gt; [*]
        }
    }
</pre>

<h3 id="machine-creation">Machine Creation</h3>
<p>Machine Creation Flow:</p>
<ul>
<li>Complex process involving multiple status checks</li>
<li>Handles initialization and error cases</li>
<li>Includes node verification and cleanup of stale resources</li>
<li>Multiple retry mechanisms for resilience</li>
</ul>
<pre class="mermaid">---
  config:
    look: handDrawn
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state &#34;From &lt;u&gt;CreateResponse&lt;/u&gt;: Assign Node Name &amp; ProviderID&#34; as ANPIDCMR
        state &#34;From &lt;u&gt;GetMachineStatusResponse&lt;/u&gt;: Assign Node Name &amp; ProviderID&#34; as ANPIDGMS
        state &#34;From &lt;u&gt;GetMachineStatusResponse&lt;/u&gt;: Assign Node Name &amp; ProviderID&#34; as ANPIDGMSR
        state &#34;Assign Node Name&lt;br/&gt;from Machine label&#34; as ANML
        state &#34;Phase: &lt;i&gt;Pending&lt;/i&gt;&lt;br/&gt;State: &lt;i&gt;Processing&lt;/i&gt;&lt;br/&gt;OpType: Create&#34; as CPPP
        state &#34;State: &lt;i&gt;Failed&lt;/i&gt;&lt;br/&gt;OpType: &lt;i&gt;Create&lt;/i&gt;&#34; as SFFF
        
        [*] --&gt; AddBootToken&amp;MachineName
        AddBootToken&amp;MachineName --&gt; GetMachineStatus:::imp
        
        GetMachineStatus:::imp --&gt; ANPIDGMS : Success
        ANPIDGMS --&gt; UpdateAnnotationsLabels
        UpdateAnnotationsLabels --&gt; CPPP : Phase &lt;i&gt;&#34;&#34;(empty) or CrashLoopBackOff&lt;/i&gt;
        CPPP --&gt; StatusUpdate
        StatusUpdate --&gt; [*]
        
        GetMachineStatus:::imp --&gt; CheckNodeExists : NotFound or Unimplemented
        CheckNodeExists --&gt; ANML : Node Exists
        ANML --&gt; UpdateAnnotationsLabels
        
        CheckNodeExists --&gt; CreateMachine:::imp : No Node
        CreateMachine:::imp --&gt; ANPIDCMR : Successful creation
        CreateMachine:::imp --&gt; CheckFailurePhase : Creation Error
        ANPIDCMR --&gt; SetUninitialized : Node name is Machine Name
        SetUninitialized --&gt; UpdateAnnotationLabel
        UpdateAnnotationLabel --&gt; InitializeMachine:::imp
        InitializeMachine:::imp --&gt; [*]
        
        ANPIDCMR --&gt; DeleteMachine:::imp : &lt;u&gt;Stale Node&lt;/u&gt;&lt;br/&gt;NodeName is not MachineName
        DeleteMachine:::imp --&gt; SFFF: &#34;VM using old node obj&#34;
        
        GetMachineStatus:::imp --&gt; ANPIDGMSR : Uninitialized
        ANPIDGMSR --&gt; SetUninitialized
        
        GetMachineStatus:::imp --&gt; CheckFailurePhase : Other Errors
        CheckFailurePhase --&gt; Failed : Timeout
        CheckFailurePhase --&gt; CrashLoopBackOff : Not timed out
        Failed --&gt; SFFF
        CrashLoopBackOff --&gt; SFFF
        
        SFFF --&gt; [*]
</pre>

<h3 id="health-check">Health Check</h3>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;Health Reconciliation&#34; as HR {
        state &#34;Phase: &lt;i&gt;Unknown&lt;/i&gt;&lt;br/&gt;State: &lt;i&gt;Processing&lt;/i&gt;&lt;br/&gt;LastOp: &lt;i&gt;HealthChk&lt;/i&gt;&#34; as PUSP
        state &#34;Phase: &lt;i&gt;Failed&lt;/i&gt;&lt;br/&gt;State: &lt;i&gt;Failed&lt;/i&gt;&#34; as PFSF
        state &#34;LastOp State: Successful&lt;br/&gt;Phase: Running&#34; as SSPR

        [*] --&gt; GetMachineNode
        GetMachineNode --&gt; PUSP : Not Found &amp; RunningPhase&lt;br/&gt;Node object missing
        GetMachineNode --&gt; Found

        Found --&gt; MachineCondSetToNodeCond : NodeCondition != MachineCondition
        Found --&gt; isHealthy : TODO (isHealthy)

        GetMachineNode --&gt; CreationTimeout : PendingPhase
        GetMachineNode --&gt; HealthTimeout : UnknownPhase

        CreationTimeout --&gt; PFSF : Now - LastUpdateTime &gt; Timeout
        HealthTimeout --&gt; GetDeploymentName : Now - LastUpdateTime &gt; Timeout
        CreationTimeout --&gt; EnqueueAfter : Not timed out
        HealthTimeout --&gt; EnqueueAfter : Not timed out


        GetDeploymentName --&gt; RegisterPermit
        RegisterPermit --&gt; TryMarkingMachineFailed
        TryMarkingMachineFailed --&gt; InProgressMachines++ : Phase not&lt;br/&gt;Unknown or Running&lt;br/&gt;Machines &#34;getting replaced&#34;
        InProgressMachines++ --&gt; PFSF:  InProgressMachines &lt; MaxReplacements(1)

        MachineCondSetToNodeCond --&gt; isHealthy
        isHealthy --&gt; PUSP: Not Healthy &amp; RunningPhase
        isHealthy --&gt; CheckLastOp : Healthy &amp; NotRunningPhase &amp;&lt;br/&gt;NoCriticalComponentNotReadyTaint

        CheckLastOp --&gt; DeleteBootstrapToken: TypeCreate &amp;&lt;br/&gt; State is not Successful&lt;br/&gt;(Machine creation happened)
        CheckLastOp --&gt; LastOpType=HealthChk: Not Create&lt;br/&gt;(Machine re-joined)

        DeleteBootstrapToken --&gt; SSPR
        LastOpType=HealthChk --&gt; SSPR

        SSPR --&gt; UpdateStatus
        PUSP --&gt; UpdateStatus
        PFSF --&gt; UpdateStatus

        UpdateStatus --&gt; [*]
        EnqueueAfter --&gt; [*]
    }       
</pre>

<h3 id="machine-deletion">Machine Deletion</h3>
<p>Machine Deletion Flow:</p>
<ul>
<li>Carefully orchestrated process to ensure clean resource cleanup</li>
<li>Involves multiple phases from drain to final cleanup</li>
<li>Handles volume attachments and node cleanup</li>
<li>Includes finalizer management for resource protection</li>
</ul>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;Deletion Flow&#34; as DF {
        direction LR
        state &#34;ProcessPhase&#34; as PP
        state &#34;UpdateStatus&#34; as US

        [*] --&gt; CheckFinalizers
        CheckFinalizers --&gt; SetTerminating
        SetTerminating --&gt; PP

        PP --&gt; GetVMStatus
        GetVMStatus --&gt; [*]
        PP --&gt; InitiateDrain
        InitiateDrain --&gt; [*]
        PP --&gt; DeleteVolumeAttachments
        DeleteVolumeAttachments --&gt; [*]
        PP --&gt; InitiateVMDeletion
        InitiateVMDeletion --&gt; [*]
        PP --&gt; InitiateNodeDeletion
        InitiateNodeDeletion --&gt; [*]
        PP --&gt; RemoveFinalizers
        RemoveFinalizers --&gt; [*]
        PP --&gt; US
        US --&gt; [*]
    }
</pre>

<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;Initiate Drain&#34; as ND {
        [*] --&gt; ValidateNode
        state &#34;UpdateStatus&#34; as USD
        state &#34;State: Processing&lt;br/&gt;Type: Delete&#34; as SPTD
        state &#34;CheckNodeCondition&lt;br/&gt;&#39;Ready&#39; or &#39;Read-only FS&#39;&#34; as CNC
        state &#34;Phase is not Terminating&#34; as NAT
        state &#34;Terminating&lt;br/&gt;Reason: Unhealthy&#34; as TRU
        state &#34;Terminating&lt;br/&gt;Reason: ScaleDown&#34; as TRSD
        state &#34;SkipDrain&lt;br/&gt;State: Failed&#34; as CUFail
        state &#34;State: Processing&lt;br/&gt;Desc: DelVolAttachments&#34; as SPDDVA
        state &#34;State: Processing&lt;br/&gt;Desc: InitVMDeletion&#34; as SPDIVD
        state &#34;State: Failed&lt;br/&gt;Desc: InitiateDrain&#34; as SFDID

        ValidateNode --&gt; SPTD : NodeName is empty
        SPTD --&gt; USD
        ValidateNode --&gt; CNC
        CNC --&gt; ForceDeletion : Read-Only/NotReady &amp;&lt;br/&gt;Last-transition Timeout
        CNC --&gt; NormalDrain : Healthy
        CNC --&gt; ForceDeletion : &#34;force-delete&#34; label on machine or Drain&lt;br/&gt; Timeout on deletion

        ForceDeletion --&gt; UpdateTerminationCondition
        NormalDrain --&gt; UpdateTerminationCondition

        UpdateTerminationCondition --&gt; RunDrain : Phase is empty or CrashLoopBackOff
        UpdateTerminationCondition --&gt; NAT : Non-creation Phase
        NAT --&gt; TRU : Phase is failed
        NAT --&gt; TRSD : Phase not failed
        TRU --&gt; TerminationConditionUpdate
        TRSD --&gt; TerminationConditionUpdate

        TerminationConditionUpdate --&gt; CUFail : Update failure&lt;br/&gt;during NormalDrain
        TerminationConditionUpdate --&gt; RunDrain : Update failure&lt;br/&gt;during ForceDeletion
        TerminationConditionUpdate --&gt; RunDrain : Update Successful
        CUFail --&gt; USD

        RunDrain --&gt; SPDDVA : Drain successful&lt;br/&gt;during ForceDeletion
        RunDrain --&gt; SPDIVD : Drain successful&lt;br/&gt;during NormalDrain
        RunDrain --&gt; SPDDVA : Drain failed&lt;br/&gt;&#34;force-delete&#34; label present
        RunDrain --&gt; SFDID : Drain failed&lt;br/&gt;&#34;force-delete&#34; label absent

        SPDDVA --&gt; USD
        SPDIVD --&gt; USD
        SFDID --&gt; USD

        USD --&gt; [*]
    }
</pre>

<p>Let&rsquo;s visualize the Node Drain process, which is a critical part of machine deletion:</p>
<ul>
<li>Sophisticated pod eviction handling</li>
<li>Supports both forced and normal drain scenarios</li>
<li>Handles PDB (Pod Disruption Budget) violations</li>
<li>Includes parallel and serial eviction strategies</li>
</ul>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;RunDrain&#34; as Normal {
        state &#34;CordonNode (Sealing off)&lt;br/&gt;(Set Unschedulable to true)&#34; as CN
        [*] --&gt; CN
        CN --&gt; WaitForPodCacheSync
        WaitForPodCacheSync --&gt; GetPodsForDeletion : TODO
        
        %% http://localhost:3000/machine-controller/node_drain.html#drainoptionsgetpodsfordeletion
        %% mirrorPodFilter: pod doesnt have MirrorPodAnnotation (set by kubelet when creating mirror pods)
        %% localStorageFilter
        %% unreplicatedFilter
        %% daemonSetFilter
        
        GetPodsForDeletion --&gt; DeleteOrEvictPods

        DeleteOrEvictPods --&gt; UpdateNodeCondition
        UpdateNodeCondition --&gt; [*]
        
        state &#34;DeleteOrEvictPods&#34; as EP {
            [*] --&gt; CheckEvictionSupport

            CheckEvictionSupport --&gt; ParallelEviction : ForceDeletion
            CheckEvictionSupport --&gt; MixedEviction : NormalDrain

            MixedEviction --&gt; ParallelEvictNoPV
            MixedEviction --&gt; SerialEvictWithPV

            ParallelEvictNoPV --&gt; WaitForEviction
            SerialEvictWithPV --&gt; WaitForEviction
            ParallelEviction --&gt; WaitForEviction
            WaitForEviction --&gt; HandlePDBViolation
            HandlePDBViolation --&gt; RetryEviction
            RetryEviction --&gt; [*]
        }
}
</pre>

<pre class="mermaid">---
title: EvictPodsNoPV
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state &#34;Retry count &gt;= MaxEvictRetries&#34; as Term
        state &#34;Set attemptEvict as False&#34; as AEF
        state &#34;Sleep(EvictRetryInterval)&#34; as SRC

        [*] --&gt; Term:::imp

        Term:::imp --&gt; CheckAttemptEvict : No
        Term:::imp --&gt; AEF : Yes
        AEF --&gt; CheckAttemptEvict

        CheckAttemptEvict --&gt; EvictPod : True
        CheckAttemptEvict --&gt; DeletePod : False

        EvictPod --&gt; CheckErr
        DeletePod --&gt; CheckErr

        CheckErr --&gt; BreakLoop:::imp : nil
        CheckErr --&gt; LogEvict : notFound
        CheckErr --&gt; EvictFailErr : AttemptEvict is False
        CheckErr --&gt; PDBViolation : APIErr too many req

        PDBViolation --&gt; GetPDB

        GetPDB --&gt; SRC : No PDB
        GetPDB --&gt; CheckMisconfigured : PDB exists

        CheckMisconfigured --&gt; MisconfigErr : Generation is ObserverGen&lt;br/&gt;HealthyPods &gt;= ExpectedPods&lt;br/&gt;DisruptionsAllowed is 0
        CheckMisconfigured --&gt; SRC : No

        SRC:::imp --&gt; Term : count++


        BreakLoop:::imp --&gt; ReturnSuccess:::imp : ForceDeletion
        BreakLoop:::imp --&gt; GetTerminationGracePeriod : NormalDrain

        GetTerminationGracePeriod --&gt; SetToTimeout : GracePeriod &gt; Timeout
        GetTerminationGracePeriod --&gt; WaitForDeletion : Grace &lt; Timeout
        SetToTimeout --&gt; WaitForDeletion

        WaitForDeletion --&gt; TimeoutErr : timeout &amp;&lt;br/&gt;pod exists
        WaitForDeletion --&gt; WaitErr : err
        WaitForDeletion --&gt; ReturnSuccess:::imp : timeout &amp;&lt;br/&gt;pod deleted

        LogEvict --&gt; [*]
        EvictFailErr --&gt; [*]
        MisconfigErr --&gt; [*]
        TimeoutErr --&gt; [*]
        WaitErr --&gt; [*]
        ReturnSuccess:::imp --&gt; [*]
</pre>

<pre class="mermaid">---
title: EvictPodsWithPV
config:
  layout: elk
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state &#34;Retry count &lt; MaxEvictRetries&#34; as Term
        state &#34;Sleep(EvictRetryInterval)&#34; as SRC
        state &#34;CheckRemainingPods&#34; as CRP
        
        [*] --&gt; SortPodsByPriority
        SortPodsByPriority --&gt; podVolumeInfoMap
        note left of podVolumeInfoMap
            Creates a map from pod to list of attached PVs (VolName, VolID -&gt; GetVolumeID)
        end note

        podVolumeInfoMap --&gt; AttemptEvict
        AttemptEvict --&gt; evictPodPVInternal(Delete):::imp : false
        AttemptEvict --&gt; Term:::imp : true
        Term:::imp --&gt; evictPodPVInternal(Evict):::imp : true
        evictPodPVInternal(Evict):::imp --&gt; break:::imp : FastTrack or&lt;br/&gt;All pods evicted
        evictPodPVInternal(Evict):::imp --&gt; SRC : Not FastTrack and&lt;br/&gt;Pods Remaining
        SRC --&gt; Term:::imp : count++

        Term:::imp --&gt; evictPodPVInternal(Delete):::imp : false&lt;br/&gt;Not FastTrack and&lt;br/&gt;Pods Remaining
        break:::imp --&gt; [*] : All pods evicted

        break:::imp --&gt; CRP : FastTrack
        evictPodPVInternal(Delete):::imp --&gt; CRP

        CRP --&gt; Success:::imp : Node Not Found
        CRP --&gt; ChkAttemptEvict
        ChkAttemptEvict --&gt; EvictErr : True
        ChkAttemptEvict --&gt; DeleteErr : False
</pre>

<pre class="mermaid">---
title: EvictPodsWithPVInternal
config:
  layout: elk
---
stateDiagram-v2
    classDef imp font-weight:bold,stroke-width:5px;
        state &#34;Add Pod to RetryPods&#34; as Retry
        state &#34;Log NotFound&lt;br/&gt;DeleteWorker&#34; as LogNotFound
        [*] --&gt; SelectPod : Start Eviction Process

        SelectPod --&gt; CheckContextTimeout:::imp

        CheckContextTimeout:::imp --&gt; AbortProcess : Context Done
        CheckContextTimeout:::imp --&gt; AddWorker(AttachmentHandler) : Context Not Done

        AddWorker(AttachmentHandler) --&gt; EvictOrDelete

        EvictOrDelete --&gt; CheckEvictionResult:::imp

        CheckEvictionResult:::imp --&gt; EvictionFailed
        EvictionFailed --&gt; PDBViolation : Eviction Attempted &amp;&lt;br/&gt;TooManyRequests
        EvictionFailed --&gt; PodAlreadyGone : Pod Not Found
        EvictionFailed --&gt; EvictionError : Other Errors
        CheckEvictionResult:::imp --&gt; WaitForVolumeDetach : Successful Eviction

        PDBViolation --&gt; GetPDB
        GetPDB --&gt; CheckMisconfigured : PDB Exists
        GetPDB --&gt; Retry : NoPDB
        CheckMisconfigured --&gt; MisconfigErr : Generation is ObserverGen&lt;br/&gt;HealthyPods &gt;= ExpectedPods&lt;br/&gt;DisruptionsAllowed is 0
        CheckMisconfigured --&gt; Retry:::imp : NotMisconfig
        MisconfigErr --&gt; DeleteWorker

        PodAlreadyGone --&gt; DeleteWorker

        EvictionError --&gt; Retry:::imp

        WaitForVolumeDetach --&gt; CheckDetachResult:::imp : TerminationGracePeriod + DetachTimeout

        CheckDetachResult:::imp --&gt; LogNotFound : Node Not Found
        CheckDetachResult:::imp --&gt; DetachError : Detach Failed
        CheckDetachResult:::imp --&gt; WaitForReattach : Successful Detach

        LogNotFound --&gt; AbortProcess
        DetachError --&gt; DeleteWorker

        WaitForReattach --&gt; CheckReattachResult:::imp : PvReattachTimeout

        CheckReattachResult:::imp --&gt; ReattachTimeout : Timeout
        CheckReattachResult:::imp --&gt; LogError : Reattach Failed
        CheckReattachResult:::imp --&gt; SuccessfulEviction:::imp : Successful Reattach

        ReattachTimeout --&gt; DeleteWorker : TODO IsThisCorrect?
        LogError --&gt; DeleteWorker
        SuccessfulEviction:::imp --&gt; DeleteWorker : Pod Processed

        DeleteWorker --&gt; [*]
        Retry:::imp --&gt; DeleteWorker
        AbortProcess --&gt; Exit:::imp : Terminate (FastTrack)&lt;br/&gt;Return Remaining Pods
</pre>

<h2 id="safety-controller">Safety Controller</h2>
<ol>
<li>
<p>Orphan VM Check:</p>
<ul>
<li>Runs periodically (every 15 minutes) to detect and clean up orphaned VMs</li>
<li>Lists all VMs in the cloud provider matching the cluster&rsquo;s tag</li>
<li>Maps VMs to machine objects using ProviderID</li>
<li>Handles nodes without machine objects:
<ul>
<li>Adds <code>NotManagedByMCM</code> annotation after timeout</li>
<li>Removes annotation if machine object is found</li>
</ul>
</li>
<li>Logs all cleanup operations for audit purposes</li>
</ul>
</li>
<li>
<p>API Server Safety:</p>
<ul>
<li>Monitors connectivity to both control and target API servers</li>
<li>Implements a freezing mechanism when API servers are unreachable</li>
<li>Manages machine controller state based on API server health:
<ul>
<li>Freezes operations if timeout exceeded</li>
<li>Unfreezes when API servers become available</li>
</ul>
</li>
<li>Handles machine status updates during API server recovery</li>
</ul>
</li>
</ol>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;Safety Controller&#34; as SC {
        state &#34;Orphan VM Check&#34; as OVC {
            [*] --&gt; ListCloudVMs
            ListCloudVMs --&gt; MapToMachines
            MapToMachines --&gt; CheckOrphans
            
            state &#34;CheckOrphans&#34; as CO {
                [*] --&gt; NoMachineObject
                NoMachineObject --&gt; ConfirmDeletion
                ConfirmDeletion --&gt; DeleteVM
                DeleteVM --&gt; LogDeletion
            }
            
            CheckOrphans --&gt; AnnotateNodes
            
            state &#34;AnnotateNodes&#34; as AN {
                [*] --&gt; CheckNodeMachine
                CheckNodeMachine --&gt; MultipleMatch : Multiple Machines
                CheckNodeMachine --&gt; NoMatch : No Machine
                CheckNodeMachine --&gt; SingleMatch : One Machine
                
                NoMatch --&gt; TimeoutCheck
                TimeoutCheck --&gt; AddAnnotation : Timeout Exceeded
                
                SingleMatch --&gt; RemoveAnnotation : Has Annotation
                
                AddAnnotation --&gt; UpdateNode
                RemoveAnnotation --&gt; UpdateNode
            }
        }

        state &#34;API Server Safety&#34; as ASS {
            [*] --&gt; CheckFrozen
            CheckFrozen --&gt; CheckAPIServer : Frozen
            CheckFrozen --&gt; MonitorAPI : Not Frozen
            
            CheckAPIServer --&gt; Unfreeze : API Up
            CheckAPIServer --&gt; Requeue : API Down
            
            MonitorAPI --&gt; SetInactiveTime : API Down
            MonitorAPI --&gt; ClearInactiveTime : API Up
            
            SetInactiveTime --&gt; CheckTimeout
            CheckTimeout --&gt; Freeze : Timeout Exceeded
            
            Unfreeze --&gt; UpdateMachines
            UpdateMachines --&gt; ResetTimeout
        }
    }
</pre>

<h2 id="machineset-controller">MachineSet Controller</h2>
<ol>
<li>
<p>Core Reconciliation:</p>
<ul>
<li>Validates MachineSet specifications</li>
<li>Manages finalizers for proper cleanup</li>
<li>Implements machine ownership through controller references</li>
<li>Synchronizes node templates and configurations</li>
</ul>
</li>
<li>
<p>Replica Management:</p>
<ul>
<li>Implements sophisticated scaling logic:
<ul>
<li>Slow-start batching for scale-up operations</li>
<li>Prioritized scale-down based on machine health</li>
</ul>
</li>
<li>Handles stale machine cleanup</li>
<li>Maintains desired replica count</li>
<li>Updates status to reflect current state</li>
</ul>
</li>
</ol>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;MachineSet Controller&#34; as MSC {
        state &#34;Sync MachineSet&lt;br/&gt;NodeTemplate&lt;br/&gt;to Machine&#34; as SyncNodeTemplates
        state &#34;Sync MachineSet&lt;br/&gt;MachineConfiguration&lt;br/&gt;to Machine&#34; as SyncMachineConfig
        state &#34;Sync MachineSet&lt;br/&gt;MachineClass.Kind&lt;br/&gt;to Machine&#34; as SyncMachineKind

        [*] --&gt; FetchMachineSet
        FetchMachineSet --&gt; ValidateSpec
        ValidateSpec --&gt; AddFinalizers : Deletion Not Requested
        
        AddFinalizers --&gt; ClaimMachines
        
        state &#34;ClaimMachines (Returns filtered machines)&#34; as CM {
            [*] --&gt; CreateControllerRefMgr
            CreateControllerRefMgr --&gt; GetControllerRef
            GetControllerRef --&gt; Orphan : Nil&lt;br/&gt;(No Owner)
            GetControllerRef --&gt; CheckUID : Not Nil&lt;br/&gt;(Owner Exists)
            
            CheckUID --&gt; Ignore : Mismatch&lt;br/&gt;(Wrong Owner)
            CheckUID --&gt; MatchSelector : UID Same
            Orphan --&gt; CheckDeletion
            CheckDeletion --&gt; SelectorMatch : No Deletion
            SelectorMatch --&gt; AdoptOrphan : Selector Match
            
            MatchSelector --&gt; KeepClaim : Selector Match&lt;br/&gt;Already Owned
            MatchSelector --&gt; DeletionCheck : Selector Mismatch
            DeletionCheck --&gt; AttemptRelease : No Deletion

            KeepClaim --&gt; AddToClaimed
            AdoptOrphan --&gt; AddToClaimed
            AttemptRelease --&gt; RemoveFromClaimed
        }
        
        ClaimMachines --&gt; SyncNodeTemplates
        SyncNodeTemplates --&gt; SyncMachineConfig
        SyncMachineConfig --&gt; SyncMachineKind
        SyncMachineKind --&gt; CheckFilteredMachines : Deletion Requested
        SyncMachineKind --&gt; ManageReplicas : No Deletion

        CheckFilteredMachines --&gt; RemoveFinalizers : Zero Owned Machines
        CheckFilteredMachines --&gt; CheckFinalizerPresent : Backed Machines
        CheckFinalizerPresent --&gt; TerminateMachines
        RemoveFinalizers --&gt; UpdateStatus
        TerminateMachines --&gt; UpdateStatus

        state &#34;ManageReplicas&#34; as MR {
            [*] --&gt; CheckMachinePhase
            CheckMachinePhase --&gt; ActiveMachines : Phase&lt;br/&gt;NotFailedOrTerminating
            CheckMachinePhase --&gt; StaleMachines : PhaseFailed

            ActiveMachines --&gt; CheckDiff
            StaleMachines --&gt; TerminateStale
            TerminateStale --&gt; CheckDiff
            
            CheckDiff --&gt; ScaleUp : ActiveMachines&lt;br/&gt;Less than&lt;br/&gt;Replica Count
            CheckDiff --&gt; ScaleDown : ActiveMachines&lt;br/&gt;More than&lt;br/&gt;Replica Count
            
            ScaleUp --&gt; NotFrozenAnd&lt;br/&gt;NotToBeDeleted
            NotFrozenAnd&lt;br/&gt;NotToBeDeleted --&gt; SlowStartBatch : TODO Expectations
            SlowStartBatch --&gt; CreateMachines
            
            ScaleDown --&gt; SortMachines
            SortMachines --&gt; DeleteExcess
        }
        
        ManageReplicas --&gt; UpdateStatus
        UpdateStatus --&gt; [*]
    }
</pre>

<h2 id="machinedeployment-controller">MachineDeployment Controller</h2>
<p>Deployment Management:</p>
<ul>
<li>Handles multiple MachineSets for a deployment</li>
<li>Maintains deployment history through revisions</li>
<li>Supports pausing and resuming deployments</li>
<li>Implements rollback functionality</li>
</ul>
<ol>
<li>
<p>Deployment Strategies:</p>
<ul>
<li>
<p>Recreate Strategy:</p>
<ul>
<li>Scales down old MachineSets completely</li>
<li>Creates and scales up new MachineSet</li>
<li>Ensures clean cutover between versions</li>
</ul>
</li>
<li>
<p>Rolling Update Strategy:</p>
<ul>
<li>Gradually scales up new MachineSet</li>
<li>Gradually scales down old MachineSets</li>
<li>Maintains availability during updates</li>
<li>Handles surge and unavailability constraints</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Scaling Operations:</p>
<ul>
<li>Detects and handles scaling events</li>
<li>Manages desired replica counts across MachineSets</li>
<li>Updates annotations for autoscaler integration</li>
<li>Ensures proper resource cleanup</li>
</ul>
</li>
</ol>
<pre class="mermaid">---
  config:
    layout: elk
---
stateDiagram-v2
    state &#34;TODO MachineDeployment Controller&#34; as MDC {
        [*] --&gt; FetchDeployment
        FetchDeployment --&gt; LogFrozenOrTBD
        LogFrozenOrTBD --&gt; ValidateSpec
        ValidateSpec --&gt; CheckDeletion
        
        state &#34;GetMachineSets&#34; as GMS {
            [*] --&gt; CreateControllerRefMgr
            CreateControllerRefMgr --&gt; GetControllerRef
            GetControllerRef --&gt; Orphan : Nil&lt;br/&gt;(No Owner)
            GetControllerRef --&gt; CheckUID : Not Nil&lt;br/&gt;(Owner Exists)

            CheckUID --&gt; Ignore : Mismatch&lt;br/&gt;(Wrong Owner)
            CheckUID --&gt; MatchSelector : UID Same
            Orphan --&gt; CheckDelete
            CheckDelete --&gt; SelectorMatch : No Deletion
            SelectorMatch --&gt; AdoptOrphan : Selector Match

            MatchSelector --&gt; KeepClaim : Selector Match&lt;br/&gt;Already Owned
            MatchSelector --&gt; DeletionCheck : Selector Mismatch
            DeletionCheck --&gt; AttemptRelease : No Deletion

            KeepClaim --&gt; AddToClaimed
            AdoptOrphan --&gt; AddToClaimed
            AttemptRelease --&gt; RemoveFromClaimed
        }
        
        CheckDeletion --&gt; AddFinalizer : No Deletion
        AddFinalizer --&gt; StatusUpdate
        StatusUpdate --&gt; GetMachineSets

        GetMachineSets --&gt; BuildMachineMap&lt;br/&gt;MSetUIDToMachines
        BuildMachineMap&lt;br/&gt;MSetUIDToMachines --&gt; DeleteChk
        DeleteChk --&gt; CheckPausedCond : No Deletion
        DeleteChk --&gt; ProcessDeletion : Deletion Requested
        
        state &#34;Process Deletion&#34; as DC {
            [*] --&gt; Exit : Finalizer&lt;br/&gt;NotPresent
            [*] --&gt; RemoveFinalizers : NoBackingMS
            [*] --&gt; TerminateMachineSets : BackingMS
            
            TerminateMachineSets --&gt; SyncStatusOnly&lt;br/&gt;UpdateMcdStatus
            RemoveFinalizers --&gt; Exit
        }

        state &#34;Check Paused Condition&#34; as CPC {
            [*] --&gt; GetCondition&lt;br/&gt;TypeProcessing
            
            GetCondition&lt;br/&gt;TypeProcessing --&gt; [*] : CondReason&lt;br/&gt;TimeOut
            GetCondition&lt;br/&gt;TypeProcessing --&gt; ExistingPaused : CondReason&lt;br/&gt;Paused
            GetCondition&lt;br/&gt;TypeProcessing --&gt; NotExistingPaused : Else
            
            NotExistingPaused --&gt; Spec.Paused
            Spec.Paused --&gt; SetPausedCondition : true

            ExistingPaused --&gt; SpecPaused
            SpecPaused --&gt; SetResumedCondition : False

            SetPausedCondition --&gt; UpdateMcdStatus
            SetResumedCondition --&gt; UpdateMcdStatus

            UpdateMcdStatus --&gt; [*]
        }

        CheckPausedCond --&gt; SetPrioAnnotation : TODO

        SetPrioAnnotation --&gt; Sync : Spec.Paused true&lt;br/&gt;TODO
        SetPrioAnnotation --&gt; CheckRollbackTo : Spec.Paused false
        
        state &#34;Rollback&#34; as RB {
            [*] --&gt; FindRevision
            FindRevision --&gt; FindMatchingMS : RollbackTo.Revision&lt;br/&gt;Present
            FindRevision --&gt; ClearRollbackTo : No last revision

            FindMatchingMS --&gt; Remove&lt;br/&gt;PreferNoSched&lt;br/&gt;Taint : MSRevisionAnnotation&lt;br/&gt;same as&lt;br/&gt;RollbackTo Revision
            FindMatchingMS --&gt; ClearRollbackTo : NoMachineSetFound
            
            Remove&lt;br/&gt;PreferNoSched&lt;br/&gt;Taint --&gt; UpdateMcdTemplate
            UpdateMcdTemplate --&gt; UpdateMcdAnnotations : Copy MS template&lt;br/&gt;Remove label&lt;br/&gt;machine-template-hash

            UpdateMcdAnnotations --&gt; ClearRollbckTo
            ClearRollbckTo --&gt; EmitRollbackEvent
        }
        
        CheckRollbackTo --&gt; Rollback : Rollback Requested
        CheckRollbackTo --&gt; IsScalingEvent : No Rollback
        
        state &#34;Is Scaling Event&#34; as SC {
            [*] --&gt; GetMS&lt;br/&gt;SyncRev
            GetMS&lt;br/&gt;SyncRev --&gt; NotScaling : err
            GetMS&lt;br/&gt;SyncRev --&gt; NotScaling : No New MS
            
            GetMS&lt;br/&gt;SyncRev --&gt; CheckActiveMS : MS Replicas &gt; 0
            CheckActiveMS --&gt; ScalingEvent : NoActiveMS &amp;&lt;br/&gt;MCD Replicas &gt; 0&lt;br/&gt;(ScaleFromZero)
            
            CheckActiveMS --&gt; GetMSDesiredReplica&lt;br/&gt;Annotation
            GetMSDesiredReplica&lt;br/&gt;Annotation --&gt; ScalingEvent : Desired not equal&lt;br/&gt;to MCD Replicas

            CheckActiveMS --&gt; NotScaling : NoActiveMS or&lt;br/&gt;Desired = MCD Replicas&lt;br/&gt;(For all active)
        }
        
        IsScalingEvent --&gt; Sync : Scale Event
        IsScalingEvent --&gt; DeployStrategy : No Scale Event

        state &#34;Sync&#34; as SN {
            [*] --&gt; GetMS&lt;br/&gt;SyncRevision
            GetMS&lt;br/&gt;SyncRevision --&gt; Scale
            Scale --&gt; CleanMCD : Paused and&lt;br/&gt;No RollbackTo
            Scale --&gt; SyncMCDStatus

            state &#34;Find Active or Latest MS&#34; as ALMS {
            [*] --&gt; SortMS by CreationTime&lt;br/&gt;FilterActiveMS
            }

            state &#34;TODO Scale&#34; as SCC {
                state &#34;ReplicasToAdd&lt;br/&gt;AllowedSize - AllMSReplicaCnt&#34; as ReplicasToAdd
                
                [*] --&gt; GetActiveOrLatestMS
                GetActiveOrLatestMS --&gt; CheckActiveMSReplicas : not nil
                GetActiveOrLatestMS --&gt; CheckNewMS&lt;br/&gt;Saturated

                CheckActiveMSReplicas --&gt; FIXME : ActiveMSRep = mcdRep

                CheckNewMS&lt;br/&gt;Saturated --&gt; ScaleDownOldMS : true
                CheckNewMS&lt;br/&gt;Saturated --&gt; IsRollingUpdate : false

                IsRollingUpdate --&gt; FilterActiveMS : true
                FilterActiveMS --&gt; GetReplicaCount&lt;br/&gt;AllMS

                GetReplicaCount&lt;br/&gt;AllMS --&gt; FindAllowedSize

                FindAllowedSize --&gt; Zero : MCD Replicas &lt;= 0
                FindAllowedSize --&gt; McdReplicas+MaxSurge : MCD Replicas &gt; 0

                Zero --&gt; ReplicasToAdd
                McdReplicas+MaxSurge --&gt; ReplicasToAdd

                ReplicasToAdd --&gt; ScaleUp : more than 0
                ReplicasToAdd --&gt; ScaleDown : &lt; 0

                ScaleUp --&gt; map[name]=NewRep : oldMS = Replicas
                ScaleUp --&gt; map[name]=NewRep : newMS = Rep+RepToAdd
                
            }
        }

        state &#34;TODO DeployStrategy&#34; as DS {
            state &#34;Recreate&#34; as RC {
                [*] --&gt; OldScaleDown
                OldScaleDown --&gt; CreateNew
                CreateNew --&gt; NewScaleUp
            }
            
            state &#34;RollingUpdate&#34; as RU {
                [*] --&gt; ScaleUpNew
                [*] --&gt; ScaleDownOld
                ScaleDownOld --&gt; CleanupOld
            }
        }
        
        DeployStrategy --&gt; UpdateStatus
        UpdateStatus --&gt; [*]
    }
        
</pre>

<h2 id="summary">Summary</h2>
<p>Each of these controllers implements sophisticated error handling and retry mechanisms:</p>
<ol>
<li>
<p>Error Handling:</p>
<ul>
<li>Categorizes errors into recoverable and non-recoverable</li>
<li>Implements exponential backoff for retries</li>
<li>Maintains error counters and conditions</li>
<li>Updates status to reflect error states</li>
</ul>
</li>
<li>
<p>Resource Protection:</p>
<ul>
<li>Uses finalizers to prevent premature deletion</li>
<li>Implements owner references for proper garbage collection</li>
<li>Maintains consistent state through careful status updates</li>
<li>Handles race conditions through proper locking</li>
</ul>
</li>
<li>
<p>Performance Considerations:</p>
<ul>
<li>Implements work queues for efficient processing</li>
<li>Uses informers for efficient cache handling</li>
<li>Batches operations when possible</li>
<li>Implements rate limiting for API calls</li>
</ul>
</li>
<li>
<p>Monitoring and Metrics:</p>
<ul>
<li>Tracks operation durations</li>
<li>Records error counts and types</li>
<li>Provides health metrics</li>
<li>Implements proper logging for debugging</li>
</ul>
</li>
</ol>
<p>The entire system works together to provide:</p>
<ol>
<li>Reliable machine lifecycle management</li>
<li>Proper cleanup of resources</li>
<li>Scaling capabilities</li>
<li>Rolling updates and rollbacks</li>
<li>Protection against race conditions and API server issues</li>
<li>Efficient resource utilization</li>
<li>Proper monitoring and debugging capabilities</li>
</ol>
<p>This comprehensive system ensures robust machine management while maintaining high availability and proper resource utilization. The controllers work together to maintain the desired state while handling various edge cases and failure scenarios.</p>

    
    

		
	</div>

	<div class="pagination">
		<a href="/notes/20241129t160749--mcm__k8s_sap_work/" class="left arrow">&#8592;</a>
		<a href="/meta/record/" class="right arrow">&#8594;</a>
		<a href="/" class="bottom">Home</a>
	</div>
	
  
					
  

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
	<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
	</script>
</main>


          		<footer>
			
			<span>
			&copy; <time>2025</time> . Made with <a href='https://gohugo.io'>Hugo</a> and <a href='https://orgmode.org'>Org</a> using the <a href='https://github.com/brongulus/tufte-hugo'>Tufte</a> theme.
			</span>
		</footer>

        </div>
        
    </div>
    
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
      import elkLayouts from 'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk/dist/mermaid-layout-elk.esm.min.mjs';

      mermaid.registerLayoutLoaders(elkLayouts);
      var config = {
          startOnLoad: true,
          
          theme: (localStorage.getItem('theme') === 'dark') ? 'dark' : 'default',
          align:'center',
      };
      mermaid.initialize(config);
      
      const toggleSwitch = document.querySelector('#dark-mode-button input[type="checkbox"]');
      toggleSwitch.addEventListener('click', () => {
          window.location.reload();
      });
    </script>
    
    <script> 
      const toggleSwitch = document.querySelector('#dark-mode-button input[type="checkbox"]');
      if (localStorage.theme) {
          toggleSwitch.checked = localStorage.theme === "dark";
      }
      function switchTheme(e) {
          const theme = e.target.checked ? "dark" : "light";
          document.documentElement.setAttribute("data-theme", theme);
          localStorage.theme = theme;
      }
      toggleSwitch.addEventListener("change", switchTheme);
    </script>
  </body>
</html>
