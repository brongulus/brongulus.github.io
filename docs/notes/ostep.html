<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2026 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OSTEP - Book Club</title>
<meta name="author" content="Tak" />
<meta name="generator" content="Org Mode" />
<script src='/css/head.js'></script> <link rel='stylesheet' type='text/css' href='/css/stylesheet.css'>
</head>
<body>
<div id="nav" class="status">
<a href='/'>bacchanalian madness</a><a href='/rss.xml'>
    <button id='rss-button' aria-label='Get RSS feed' type='button'>
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 448 512' fill='currentColor'>
        <path d='M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z'></path>
      </svg>
    </button>
  </a><button id='dark-mode-button' aria-label='Toggle Dark Mode' type='button'>
    <svg id='moon-icon' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'>
      <path d='M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z'></path>
    </svg>
    <svg id='sun-icon' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor' style='display: none;'>
      <path d='M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z' fill-rule='evenodd' clip-rule='evenodd'></path>
    </svg>
  </button>
</div>
<div id="content" class="content">
<header>
<h1 class="title">OSTEP - Book Club</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9d61927">Introduction</a></li>
</ul>
</div>
</nav>
<p>Schedule: <a href="https://eatonphil.com/2026-ostep.html">https://eatonphil.com/2026-ostep.html</a>
</p>

<p>Homepage: <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">https://pages.cs.wisc.edu/~remzi/OSTEP/</a>
Code: <a href="https://github.com/remzi-arpacidusseau/ostep-code">https://github.com/remzi-arpacidusseau/ostep-code</a>
Homework: <a href="https://github.com/remzi-arpacidusseau/ostep-homework">https://github.com/remzi-arpacidusseau/ostep-homework</a>
Projects: <a href="https://github.com/remzi-arpacidusseau/ostep-projects">https://github.com/remzi-arpacidusseau/ostep-projects</a>
</p>
<div id="outline-container-org9d61927" class="outline-2">
<h2 id="org9d61927">Introduction</h2>
<div class="outline-text-2" id="text-org9d61927">
<p>In a socratic fashion, the first chapter is a dialogue between a <i>Professor</i> and a <i>Student</i> where the key ideas and how best to learn from the book is talked about.
</p>

<p>The three easy pieces refer to <i>virtualization</i>, <i>concurrency</i> and <i>persistence</i>. These ideas will teach one how an OS works, how it decides what program to run next, how it handles memory overload in a virtual memory system, how virtual machine monitors work, how it manages information on disks etc.
</p>

<p>The next chapter is an introduction to the three pieces with illustrative examples and how OS takes physical <i>resources</i>, <i>virtualizes</i> them, handles <i>concurrency</i> and stores files <i>persistently</i>. The goal in designing such a system is to provide high <i>performance</i> or to <i>minimize overheads</i> (extra time or space) of the OS. Furthermore, it should also offer <i>protection</i> (isolation) between applications, OS and the application while being <i>reliable</i>.
</p>

<p>Then the book talks abouts execution of programs and tries to define the operating system.
</p>

<p>A running program executes instructions. The processor <i>fetches</i> an instruction from memory, <i>decodes</i> it (find out what instruction), and <i>executes</i> it; then moves on to the next instruction until the program finishes. The body of software allowing the computer to manage running of various programs to ensure they run correctly and efficiently is known as the <i>Operating System</i>.
</p>

<p>To make it easier to manage resources of the system OS takes the <i>physical</i> resource (CPU, memory or disk) and transforms it into a <i>virtual</i> form, giving the OS the nickname <i>virtual machine</i> or <i>resource manager</i>. The first part of the book aims to deal with <b>how</b> virtualization is done.
</p>

<p>The chapter ends with a history of how operating systems were developed from early libraries to multiprogramming to PCs running DOS, linux and macOS.
</p>
</div>
<div id="outline-container-orgefcaad0" class="outline-3">
<h3 id="orgefcaad0">CPU Virtualization</h3>
<div class="outline-text-3" id="text-orgefcaad0">
<pre class="src src-C"><code><span class="font-lock-preprocessor-face">#if</span><span class="font-lock-preprocessor-face font-lock-negation-char-face">n</span><span class="font-lock-preprocessor-face">def</span> __common_h__
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-variable-name-face">__common_h__</span>

<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;sys/time.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;sys/stat.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;assert.h&gt;</span>

<span class="font-lock-type-face">double</span> <span class="font-lock-function-name-face">GetTime</span>() {
    <span class="font-lock-keyword-face">struct</span> <span class="font-lock-type-face">timeval</span> <span class="font-lock-variable-name-face">t</span>;
    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">rc</span> = gettimeofday(&amp;t, <span class="font-lock-constant-face">NULL</span>);
    assert(rc == 0);
    <span class="font-lock-keyword-face">return</span> (<span class="font-lock-type-face">double</span>) t.tv_sec + (<span class="font-lock-type-face">double</span>) t.tv_usec/1e6;
}

<span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">Repeatedly checks time and returns once 1s has passed.
</span><span class="font-lock-type-face">void</span> <span class="font-lock-function-name-face">Spin</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">howlong</span>) {
    <span class="font-lock-type-face">double</span> <span class="font-lock-variable-name-face">t</span> = GetTime();
    <span class="font-lock-keyword-face">while</span> ((GetTime() - t) &lt; (<span class="font-lock-type-face">double</span>) howlong)
        ; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">do nothing in loop
</span>}

<span class="font-lock-preprocessor-face">#endif</span> <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">__common_h__</span></code></pre>

<pre class="src src-C"><code><span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdio.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdlib.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;assert.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;sys/time.h&gt;</span>
&lt;&lt;include-common&gt;&gt;

<span class="font-lock-type-face">int</span> main(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">argc</span>, <span class="font-lock-type-face">char</span> *<span class="font-lock-variable-name-face">argv</span>[]) {
    <span class="font-lock-keyword-face">if</span> (argc != 2) {
        fprintf(stderr, <span class="font-lock-string-face">"usage: cpu &lt;string&gt;\n"</span>);
        exit(1);
    }
    <span class="font-lock-type-face">char</span> *<span class="font-lock-variable-name-face">str</span> = argv[1];
    setbuf(stdout, <span class="font-lock-constant-face">NULL</span>); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">disable buffering
</span>    <span class="font-lock-type-face">double</span> <span class="font-lock-variable-name-face">start</span> = GetTime();
    <span class="font-lock-keyword-face">while</span>(GetTime() - start &lt; 5.0) {
        Spin(1);
        printf(<span class="font-lock-string-face">"(%d) %s\n"</span>, getpid(), str);
    }
    <span class="font-lock-keyword-face">return</span> 0;
}</code></pre>

<p>Compiling and executing the above gives the result:
</p>

<pre class="src src-sh"><code>gcc -o cpu cpu.c -I.
./cpu <span class="font-lock-string-face">"A"</span> &amp; ./cpu <span class="font-lock-string-face">"B"</span> &amp;
<span class="font-lock-builtin-face">wait</span></code></pre>

<details>
<summary>Output</summary>
<pre class="example" id="orgbb987e1">
A
B
A
B
A
B
A
B
A
B
</pre>

</details><p>Even though there&rsquo;s only one processor, the execution of the two programs <code>./cpu "A"</code> and <code>./cpu "B"</code> seems to be happening at the same time, this is because of <i>CPU virtualization</i>. But for two programs to run simultaneously, the OS needs to have a <i>policy</i> to decide which should run.
</p>
</div>
</div>
<div id="outline-container-org93c9af6" class="outline-3">
<h3 id="org93c9af6">Memory Virtualization</h3>
<div class="outline-text-3" id="text-org93c9af6">
<p>Physical memory is just an array of bytes; to <i>read</i> or <i>write</i> memory, an <i>address</i> must be specified to access the data there.
</p>

<pre class="src src-C"><code><span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdio.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdlib.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;unistd.h&gt;</span>
&lt;&lt;include-common&gt;&gt;

<span class="font-lock-type-face">int</span> main(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">argc</span>, <span class="font-lock-type-face">char</span> *<span class="font-lock-variable-name-face">argv</span>[]) {
    <span class="font-lock-type-face">int</span> *<span class="font-lock-variable-name-face">p</span> = malloc(<span class="font-lock-keyword-face">sizeof</span>(<span class="font-lock-type-face">int</span>)); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">memory allocation
</span>    assert(p != <span class="font-lock-constant-face">NULL</span>);
    printf(<span class="font-lock-string-face">"(%d) address pointed to by p -&gt; %p\n"</span>, getpid(), p); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">mem addr
</span>    *p = 0; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">write 0 to location specified by memory address
</span>    <span class="font-lock-type-face">double</span> <span class="font-lock-variable-name-face">start</span> = GetTime();
    setbuf(stdout, <span class="font-lock-constant-face">NULL</span>); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">disable buffering
</span>    <span class="font-lock-keyword-face">while</span>(GetTime() - start &lt; 5.0) {
        Spin(1);
        *p = *p + 1; <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">update value at the location by 1
</span>        printf(<span class="font-lock-string-face">"(%d) p =&gt; %d addr -&gt; %p\n"</span>, getpid(), *p, p);
    }
    <span class="font-lock-keyword-face">return</span> 0;
}</code></pre>

<pre class="src src-sh"><code>gcc -o mem mem.c -I.
./mem &amp; ./mem &amp;
<span class="font-lock-builtin-face">wait</span></code></pre>

<details>
<summary>Output</summary>
<pre class="example" id="orgfe5d641">
(19998) address pointed to by p -&gt; 0x1047cd830
(19997) address pointed to by p -&gt; 0x10263d830
(19997) p =&gt; 1 addr -&gt; 0x10263d830
(19998) p =&gt; 1 addr -&gt; 0x1047cd830
(19997) p =&gt; 2 addr -&gt; 0x10263d830
(19998) p =&gt; 2 addr -&gt; 0x1047cd830
(19997) p =&gt; 3 addr -&gt; 0x10263d830
(19998) p =&gt; 3 addr -&gt; 0x1047cd830
(19997) p =&gt; 4 addr -&gt; 0x10263d830
(19998) p =&gt; 4 addr -&gt; 0x1047cd830
(19997) p =&gt; 5 addr -&gt; 0x10263d830
(19998) p =&gt; 5 addr -&gt; 0x1047cd830
</pre>

</details><p>In the textbook example, for both instances of the program, the memory was allocated to the same address, this was used to illustrate that each running program has its own private memory (<b>memory virtualization</b>, private <i>address space</i> that gets mapped to physical memory) rather than sharing physical memory with other programs.
</p>

<p>However for security purposes, <code>macOS</code> has enabled <code>address-space layout randomization</code> (ASLR) hence the different addresses for the two processes.
</p>
</div>
</div>
<div id="outline-container-org687d5fa" class="outline-3">
<h3 id="org687d5fa">Concurrency</h3>
<div class="outline-text-3" id="text-org687d5fa">
<pre class="src src-C"><code><span class="font-lock-preprocessor-face">#if</span><span class="font-lock-preprocessor-face font-lock-negation-char-face">n</span><span class="font-lock-preprocessor-face">def</span> __common_threads_h__
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-variable-name-face">__common_threads_h__</span>

<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;pthread.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;assert.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;sched.h&gt;</span>

<span class="font-lock-preprocessor-face">#ifdef</span> __linux__
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;semaphore.h&gt;</span>
<span class="font-lock-preprocessor-face">#endif</span>

<span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">wrapper around pthread_create() that ensures the return value is success
</span><span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Pthread_create</span>(<span class="font-lock-variable-name-face">thread</span>, <span class="font-lock-variable-name-face">attr</span>, <span class="font-lock-variable-name-face">start_routine</span>, <span class="font-lock-variable-name-face">arg</span>) assert(pthread_create(thread, attr, start_routine, arg) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Pthread_join</span>(<span class="font-lock-variable-name-face">thread</span>, <span class="font-lock-variable-name-face">value_ptr</span>)                  assert(pthread_join(thread, value_ptr) == 0);

<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Pthread_mutex_lock</span>(<span class="font-lock-variable-name-face">m</span>)                            assert(pthread_mutex_lock(m) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Pthread_mutex_unlock</span>(<span class="font-lock-variable-name-face">m</span>)                          assert(pthread_mutex_unlock(m) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Pthread_cond_signal</span>(<span class="font-lock-variable-name-face">cond</span>)                        assert(pthread_cond_signal(cond) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Pthread_cond_wait</span>(<span class="font-lock-variable-name-face">cond</span>, <span class="font-lock-variable-name-face">mutex</span>)                   assert(pthread_cond_wait(cond, mutex) == 0);

<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Mutex_init</span>(<span class="font-lock-variable-name-face">m</span>)                                    assert(pthread_mutex_init(m, <span class="font-lock-constant-face">NULL</span>) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Mutex_lock</span>(<span class="font-lock-variable-name-face">m</span>)                                    assert(pthread_mutex_lock(m) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Mutex_unlock</span>(<span class="font-lock-variable-name-face">m</span>)                                  assert(pthread_mutex_unlock(m) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Cond_init</span>(<span class="font-lock-variable-name-face">cond</span>)                                  assert(pthread_cond_init(cond, <span class="font-lock-constant-face">NULL</span>) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Cond_signal</span>(<span class="font-lock-variable-name-face">cond</span>)                                assert(pthread_cond_signal(cond) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Cond_wait</span>(<span class="font-lock-variable-name-face">cond</span>, <span class="font-lock-variable-name-face">mutex</span>)                           assert(pthread_cond_wait(cond, mutex) == 0);

<span class="font-lock-preprocessor-face">#ifdef</span> __linux__
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Sem_init</span>(<span class="font-lock-variable-name-face">sem</span>, <span class="font-lock-variable-name-face">value</span>)                             assert(sem_init(sem, 0, value) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Sem_wait</span>(<span class="font-lock-variable-name-face">sem</span>)                                    assert(sem_wait(sem) == 0);
<span class="font-lock-preprocessor-face">#define</span> <span class="font-lock-function-name-face">Sem_post</span>(<span class="font-lock-variable-name-face">sem</span>)                                    assert(sem_post(sem) == 0);
<span class="font-lock-preprocessor-face">#endif</span> <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">__linux__
</span>
<span class="font-lock-preprocessor-face">#endif</span> <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">__common_threads_h__</span></code></pre>

<pre class="src src-C"><code><span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdio.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdlib.h&gt;</span>
&lt;&lt;include-common&gt;&gt;
&lt;&lt;include-common_threads&gt;&gt;

<span class="font-lock-keyword-face">volatile</span> <span class="font-lock-type-face">int</span> counter = 0;
<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">loops</span>;

<span class="font-lock-type-face">void</span> *<span class="font-lock-function-name-face">worker</span>(<span class="font-lock-type-face">void</span> *<span class="font-lock-variable-name-face">arg</span>) {
    <span class="font-lock-keyword-face">for</span> (<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">i</span> = 0; i &lt; loops; i++) {
        counter++;
    }
    <span class="font-lock-keyword-face">return</span> <span class="font-lock-constant-face">NULL</span>;
}

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">argc</span>, <span class="font-lock-type-face">char</span> *<span class="font-lock-variable-name-face">argv</span>[]) {
    <span class="font-lock-keyword-face">if</span> (argc != 2) {
        fprintf(stderr, <span class="font-lock-string-face">"usage: threads &lt;value&gt;\n"</span>);
        exit(1);
    }
    loops = atoi(argv[1]);
    <span class="font-lock-type-face">pthread_t</span> <span class="font-lock-variable-name-face">p1</span>, <span class="font-lock-variable-name-face">p2</span>;
    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">setbuf(stdout, NULL); // disable buffering
</span>    printf(<span class="font-lock-string-face">"Initial value: %d\n"</span>, counter);

    Pthread_create(&amp;p1, <span class="font-lock-constant-face">NULL</span>, worker, <span class="font-lock-constant-face">NULL</span>);
    Pthread_create(&amp;p2, <span class="font-lock-constant-face">NULL</span>, worker, <span class="font-lock-constant-face">NULL</span>);
    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">The pthread_join() function suspends execution of the calling thread (main)
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">until the target thread (p1/p2) terminates unless the target thread
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">has already terminated.
</span>    Pthread_join(p1, <span class="font-lock-constant-face">NULL</span>);
    Pthread_join(p2, <span class="font-lock-constant-face">NULL</span>);

    printf(<span class="font-lock-string-face">"Final value: %d\n"</span>, counter);
    <span class="font-lock-keyword-face">return</span> 0;
}</code></pre>

<p>Think of the thread as a function running withing the same memory space as other functions, with more than one of them active at a time. Here each thread starts running in the <code>worker()</code> routine which increments the counter for <code>loops</code> number of times. Given <code>loops</code> as <code>1000</code>, the expectation is that the final value of <code>counter</code> should be <code>2000</code> but that&rsquo;s not guaranteed.
</p>

<pre class="src src-sh"><code>gcc -o threads threads.c -I. -pthread
./threads 1000
<span class="font-lock-builtin-face">wait</span>
./threads 100000
<span class="font-lock-builtin-face">wait</span>
./threads 100000
<span class="font-lock-builtin-face">wait</span></code></pre>

<pre class="example">
Initial value: 0
Final value: 1172
Initial value: 0
Final value: 100051
Initial value: 0
Final value: 101961
</pre>


<p>There&rsquo;s a different final <code>counter</code> value each time the program is executed, even with the same <code>loops</code> value. This is because the instructions of the <code>worker()</code> routine aren&rsquo;t <b>atomic</b> i.e. there are three separate instructions involved in updating the counter value:
</p>
<ol class="org-ol">
<li>Load counter value in register</li>
<li>Increment the value</li>
<li>Store it from register back to memory</li>
</ol>

<p>If instructions aren&rsquo;t atomic and there are multiple concurrent threads executing withtin the same memory space, how can the program&rsquo;s correctness and efficiency be ensured?
</p>

<p>To see the documentation for <code>pthread_create</code> check the following man page.
</p>

<pre class="src src-sh"><code>man 3 pthread_create | col -b | head -n 45</code></pre>

<details>
<summary>Output</summary>
<pre class="example" id="orgea87a82">
PTHREAD_CREATE(3)	   Library Functions Manual	     PTHREAD_CREATE(3)

NAME
     pthread_create – create a new thread

SYNOPSIS
     #include &lt;pthread.h&gt;

     int
     pthread_create(pthread_t *thread, const pthread_attr_t *attr,
	 void *(*start_routine)(void *), void *arg);

DESCRIPTION
     The pthread_create() function is used to create a new thread, with
     attributes specified by attr, within a process.  If attr is NULL, the
     default attributes are used.  If the attributes specified by attr are
     modified later, the thread's attributes are not affected.	Upon
     successful completion pthread_create() will store the ID of the created
     thread in the location specified by thread.

     The thread is created executing start_routine with arg as its sole
     argument.	If the start_routine returns, the effect is as if there was an
     implicit call to pthread_exit() using the return value of start_routine
     as the exit status.  Note that the thread in which main() was originally
     invoked differs from this.  When it returns from main(), the effect is as
     if there was an implicit call to exit() using the return value of main()
     as the exit status.

     Upon thread exit the storage for the thread must be reclaimed by another
     thread via a call to pthread_join().  Alternatively, pthread_detach() may
     be called on the thread to indicate that the system may automatically
     reclaim the thread storage upon exit.  The pthread_attr_setdetachstate()
     function may be used on the attr argument passed to pthread_create() in
     order to achieve the same effect as a call to pthread_detach() on the
     newly created thread.

     The signal state of the new thread is initialized as:

	   •   The signal mask is inherited from the creating thread.

	   •   The set of signals pending for the new thread is empty.

RETURN VALUES
     If successful, the pthread_create() function will return zero.  Otherwise
     an error number will be returned to indicate the error.
</pre>

</details>
</div>
</div>
<div id="outline-container-org512bd4c" class="outline-3">
<h3 id="org512bd4c">Persistence</h3>
<div class="outline-text-3" id="text-org512bd4c">
<p>Final major theme of <i>persistence</i> relates to determinate data storage and not be dependent on <i>volatile</i> memory. The software in the OS that manages the disk is called <i>file system</i>. Unlike CPU and memory abstractions, the expectation when is comes to files is that the user would <b>want to share</b> the data in files with processes hence there is no need of virtualization of disk.
</p>

<pre class="src src-C"><code><span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;stdio.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;unistd.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;assert.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;fcntl.h&gt;</span>
<span class="font-lock-preprocessor-face">#include</span> <span class="font-lock-string-face">&lt;sys/types.h&gt;</span>

<span class="font-lock-type-face">int</span> <span class="font-lock-function-name-face">main</span>(<span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">argc</span>, <span class="font-lock-type-face">char</span> *<span class="font-lock-variable-name-face">argv</span>[]) {
    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">The file name specified by path is opened for reading and/or writing, as
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">specified by the argument oflag; the file descriptor is returned to the
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">calling process.
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">O_WRONLY: open for writing only (O_RONLY, O_RDWR, O_SEARCH, O_EXEC)
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">O_CREAT: create file if not exist, O_TRUNC: truncate size to 0 if exist
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">S_IRWXU:  00700 user (file owner) has read, write &amp; execute permission
</span>    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">fd</span> = open(<span class="font-lock-string-face">"/tmp/file_ostep"</span>, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU);
    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">If successful, open() returns a non-negative integer, termed a file
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">descriptor.  It returns -1 on failure, and sets errno to indicate the
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">error.
</span>    assert(fd &gt; -1);
    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">write() attempts to write nbyte of data to the object referenced by the
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">descriptor fd from the buffer pointed to by buf.  Upon successful completion
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">the number of bytes which were written is returned otherwise -1.
</span>    <span class="font-lock-type-face">int</span> <span class="font-lock-variable-name-face">rc</span> = write(fd, <span class="font-lock-string-face">"hello world\n"</span>, 12); <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">12 = nbyte
</span>    assert(rc == 12);
    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">The close() call deletes a descriptor from the per-process object
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">reference table.  If this is the last reference to the underlying object,
</span>    <span class="font-lock-comment-delimiter-face">// </span><span class="font-lock-comment-face">the object will be deactivated. `man 2 close` 
</span>    close(fd);
    <span class="font-lock-keyword-face">return</span> 0;
}</code></pre>

<pre class="src src-sh"><code>gcc -o io io.c
./io
<span class="font-lock-builtin-face">wait</span>
cat /tmp/file_ostep</code></pre>

<pre class="example">
hello world
</pre>


<p>Here, <code>open()</code>, <code>write()</code> and <code>close()</code> are <i>system calls</i> that are routed to the <i>file system</i> which handles these requests and returns their response to the user.
</p>
</div>
</div>
<div id="outline-container-org8ba125f" class="outline-3">
<h3 id="org8ba125f">Discussion links</h3>
<div class="outline-text-3" id="text-org8ba125f">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Singularity_(operating_system)#Security_design">SingularityOS</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLowKtXNTBypFbtuVMUVXNR0z1mu7dp7eH">Ben Eater Video</a></li>
<li><a href="https://sel4.systems/About/whitepaper.html">sel4</a></li>
</ul>
</div>
</div>
</div>
</div>
<footer id="postamble" class="status">
&copy; 2026 . Made with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 31.0.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11).
</footer>
</body>
</html>
